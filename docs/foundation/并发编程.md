# 基础篇

## 并发编程基础

### 进程与线程

#### 进程

进程是操作系统进行资源分配和调度的最小单元，可以简单地理解为系统中运行的一个程序就是一个进程。

#### 线程

线程是CPU分配调度的最小单位，是进程中的一个个执行流程。

#### 关系

- 一个进程至少包含一个线程，可以包含多个线程，这些线程共享这个进程的资源（比如堆区和方法区资源）。同时每个线程都拥有独立的运行栈和程序计数器，线程切换开销小

- 多进程指的是操作系统同时运行多个程序，如当前操作系统中同时运行着QQ、IE、微信等程序。

  多线程指的是同一进程中同时运行多个线程，如迅雷运行时，可以开启多个线程，同时进行多个文件的下载。

进程与线程的关系如图：

![](E:\软件\Typora\images\1-1607432932515.png)

- 程序计数器就是为了记录该线程让出CPU时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行
- 每个线程都有自己的栈资源，用于存储该线程的局部变量和调用栈帧
- 堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放使用new操作创建的对象实例
- 方法区则用来存放JVM加载的类、常量及静态变量等信息

#### 各个ID

- pid：进程ID
- tgid：线程组ID，也就是线程组leader的进程ID，等于pid
- lwp：进程ID，在用户态的命令（比如ps）中常用的显示方式
- tid：线程ID，等于lwp，tid在系统提供的接口函数中更常用，比如syscall(SYS_gettid)和syscall(__NR_gettid)

### 并行与并发

#### 并发

并发是指同一时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时进行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内并不一定同时在执行。

#### 并行

并行是指在单位时间内多个任务同时在执行

### 线程安全

我一开始认为线程安全讲的是某个共享变量线程安全，其实我们所说的线程安全是指某段代码或者是某个方法是线程安全的。

线程安全准确定义应该是这样的：

**如果线程的随机调度顺序不影响某段代码的最后执行结果，那么我们认为这段代码是线程安全 的。**

为了保证代码的线程安全，Java推出了很多好用的工具类或者关键字，比如`volatile`、`synchronized`、`ThreadLocal`、锁、并发集合、线程池和CAS机制等。

### 线程状态

一个线程从创建到消亡会经历新建状态（New）、就绪状态（Runnable）、运行状态（Running）、等待（Waiting）、阻塞状态（Blocked）和死亡状态（Dead）

![线程状态流转图](https://img2018.cnblogs.com/blog/1775037/201911/1775037-20191112153234240-689002981.png)

下面对这几种状态做下简单解释：

- 新建状态（New）： 新创建了一个线程对象，还未调用线程的start()方法。

- 就绪状态（Runnable）： 线程对象创建后，其他线程调用了该对象的start()方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

- 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码的状态，还有种可能就是这个线程正在等待其他的系统资源（IO资源等），这种状态也称为Running状态。

  **需要注意的是，通过Thread::getStatus查看状态时，Runnable状态和Running统一称为Runnable状态。**

- 阻塞状态（Blocked）：一个线程因为等待监视锁而被阻塞的状态，也称之为阻塞状态。

  **阻塞的线程不会被分配CPU资源**。

- 等待状态（WAITING）：一个正在等待的线程的状态，也称之为等待状态。

  造成线程等待的原因有三种，分别是调用Object.wait()、join()以及LockSupport.park()方法。

  处于等待状态的线程，正在等待其他线程去执行一个特定的操作。

  例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。

  **处于等待状态的线程不会被分配CPU资源**。

- 超时等待（TIMED_WAITING）：一个在限定时间内等待的线程的状态。也称之为限时等待状态。

- 造成线程限时等待状态的原因有五种是：Thread.sleep(long)、Object.wait(long)、join(long)、LockSupport.parkNanos(obj,long)和LockSupport.parkUntil(obj,long)

- 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期(当时如果线程被持久持有，可能不会被回收)



#### 三种阻塞状态对比

对于线程的新建、就绪、运行和死亡状态，我们都比较好理解。

线程的另外3个状态的含义可能会让人比较困惑。下面就来解释下这三种状态的区别：

**1. 超时等待状态（TIMED_WAITING）**
Java文档官方定义TIMED_WAITING状态为：“一个线程在一个特定的等待时间内等待另一个线程完成一个动作会在这个状态”。调用下面的这些方法会让线程进入TIMED_WAITING状态。

- Thread#sleep()；
- Object#wait() 并加了超时参数；
- Thread#join() 并加了超时参数；
- LockSupport#parkNanos()；
- LockSupport#parkUntil()。

**2. 等待状态（WAITING）**
Java文档官方定义WAITING状态是：“一个线程在等待另一个线程执行一个动作时在这个状态。”

当线程调用以下方法时会进入WAITING状态：

- Object#wait() 而且不加超时参数
- Thread#join() 而且不加超时参数
- LockSupport#park()。

在对象上的线程调用了Object.wait()会进入WAITING状态，直到另一个线程在这个对象上调用了Object.notify()或Object.notifyAll()方法才能恢复。一个调用了Thread.join()的线程会进入WAITING状态直到一个特定的线程来结束。

**3. BLOCKED状态**
Java文档官方定义BLOCKED状态是：“这种状态是指一个阻塞线程在等待monitor锁。”

### 线程相关方法

#### 线程创建与运行

##### 1.继承Thread类并重写run方法

```
public class ThreadTest {
    /**
     * 继承Thread类并重写run方法
     */
    public static class MyThread extends Thread{
        @Override
        public void run() {
            System.out.println("I am a child thread");
        }
    }

    public static void main(String[] args) {
        // 创建线程
        MyThread myThread = new MyThread();
        // 启动线程
        myThread.start();
    }
}
```

当创建完`myThread`对象后该线程并没有被启动执行，直到调用了start方法后才真正启动了线程。

**调用start方法后线程并没有马上执行而是出于就绪状态**，这个就绪状态是指该线程已经获取了除CPU资源外的其他资源，等待获取CPU资源后才会真正处于运行状态。

**好处**：在run()方法内获取当前线程直接使用this就可以了，无须使用`Thread.currentThread()`方法，方便传参

**坏处**：Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类，没有返回值



##### 2.实现Runnable接口的run方法

```
public class ThreadTest {
    public static class RunnableTask implements Runnable{
        @Override
        public void run() {
            System.out.println("I am a child thread");
        }
    }

    public static void main(String[] args) {
        RunnableTask task = new RunnableTask();
        new Thread(task).start();
        new Thread(task).start();
    }
}
```

可以继承其他类但没有返回值

##### 3.使用`FutureTask`方式（实现Callable接口）



```
public class ThreadTest {
    /**
     * 创建任务类，类似Runnable
     */
    public static class CallerTask implements Callable<String>{
        @Override
        public String call() {
            return "hello";
        }
    }

    public static void main(String[] args) {
        // 创建一个FutureTask对象（构造函数为CallerTask的实例）
        FutureTask<String> futureTask = new FutureTask<>(new CallerTask());
        // 使用创建的FutureTask对象作为任务创建了一个线程并启动
        new Thread(futureTask).start();
        try {
            // 通过futureTask.get()等待任务执行完毕并返回结果
            String result = futureTask.get();
            System.out.println(result);
        } catch (ExecutionException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



#### 线程通知与等待

##### 1.wait()函数

当一个线程调用一个共享变量的wait()方法时，该调用线程会被阻塞挂起，直到发生下面几件事情之一才返回：

1. 其他线程调用了该共享对象的`notify()`或者`notifyAll()`方法
2. 其他线程调用了该线程的`interrupt()`方法，该线程抛出`InterruptedException`异常返回

（如果调用wait()方法的线程事先没有获取该对象的监视器锁，则调用wait()方法时调用线程会抛出`IllegalMonitorStateException`异常）

> 如何获取监视器锁：
>
> 1. 执行synchronized同步代码块时，使用该共享变量作为参数
>
>    ```
>    synchronized(共享变量){
>      //do something
>    }
>    ```
>
> 2. 调用该共享变量的方法，并且该方法使用了synchronized修饰
>
>    ```
>    synchronized void add(int a, int b){
>      //do something
>    }
>    ```

当前线程调用共享变量的wait()方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的。

##### 2.notify()函数

一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。

类似wait系列方法，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify()方法，否则会抛出`IllegalMonitorStateException`异常

##### 3.notifyAll()函数

该方法会唤醒所有在该共享变量上由于调用wait系列方法而被挂起的线程

> 注意：在共享变量上调用`notifyAll()`方法只会唤醒调用这个方法前调用了wait系列函数而被放入共享变量等待集合里面的线程





### 线程上下文切换

在多线程编程中，线程一般都大于CPU个数，而每个CPU同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的，CPU资源的分配采用了**时间片轮转**的策略，也就是给每个线程分配一个时间片，线程在时间片内占用CPU执行任务。

当前线程使用完时间片后，就会处于就绪状态并让出CPU给其他线程占用，这就是上下文切换，从当前线程的上下文切换到了其他线程。



**那上下文都包括哪些内容呢？**

具体来说，它包括了寄存器的存储内容以及程序计数器存储的指令内容。CPU寄存器负责存储已经、正在和将要执行的任务，程序计数器负责存储CPU正在执行的指令位置以及即将执行的下一条指令的位置。



**什么原因会导致上下文切换？**

- CPU时间片用完，导致正常的上下文切换
- sleep()、wait()、yield(）、join()、park()、synchronized、lock这些方法或者关键字会导致线程状态的切换，所以这些方法的调用也会导致上下文切换（需要注意的是这些方法的调用虽然会导致上下文切换，但是并不会占用CPU资源，也就是说并不会提升CPU使用率）
- 另外，JVM在进行垃圾回收时，会进行STW，这个操作会暂停所有Java线程，垃圾收集完之后线程再进入工作状态，其实这个也是一种上下文切换操作



那么就有一个问题，让出CPU的线程等下次轮到自己占有CPU时如何知道自己之前运行到哪里了？所以在切换上下文时需要保存当前线程的执行线场，当再次执行时根据保存的执行现场信息恢复执行现场。

> ==执行现场保存在哪里？==



**线程切换上下文的时机有：**

1. 当前线程的CPU时间片使用完处于就绪状态时
2. 当前线程被其他线程中断时



**减少上下文切换的措施：**

- 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据
- CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁
- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换



### 守护线程与用户线程

只要有一个用户线程还没结束，正常情况下JVM就不会退出。

【如何创建一个守护线程】，代码如下：

```
Thread daemonThread = new Thread(new Runnable() {
     @Override
     public void run() {

     }
});
// 设置为守护线程
daemonThread.setDaemon(true);
daemonThread.start();
```

只需要设置线程的daemon参数为true即可

### 线程死锁

#### 什么是线程死锁

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。

在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。

![线程死锁](E:\软件\Typora\images\线程死锁.png)



##### 死锁的四个条件

- **互斥条件**

  即该资源同时只由一个线程占用，如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源

- **请求并持有条件**

  指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源

- **不可剥夺条件**

  指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源

- **环路等待条件**

  指在发生死锁时，必然存在一个线程-资源的环形链，即线程集合{T0,T1,...,Tn}中的T0正在等待T1占用的资源，T1正在等待T2占用的资源，...Tn正在等待已被T0占用的资源

【线程死锁】，代码如下：

```
public class DeadLock {
    /**
     * 创建资源
     */
    private static Object resourceA = new Object();
    private static Object resourceB = new Object();

    public static void main(String[] args) {
        // 创建线程A
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    System.out.println(Thread.currentThread() + "get resourceA");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread() + "waiting get resourceB");
                    synchronized (resourceB) {
                        System.out.println(Thread.currentThread() + "get resourceB");
                    }
                }

            }
        });

        // 创建线程B
        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceB) {
                    System.out.println(Thread.currentThread() + "get resourceB");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread() + "waiting get resourceA");
                    synchronized (resourceA) {
                        System.out.println(Thread.currentThread() + "get resourceA");
                    }
                }

            }
        });

        threadA.start();
        threadB.start();
    }
}
```

输出结果：

![image-20201209214732014](E:\软件\Typora\images\image-20201209214732014.png)



#### 如何避免线程死锁

要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可。

学过操作系统的读者都知道，目前只有请求并保持和环路等待条件是可以被破坏的。

**使用资源申请的有序性原则**就可以避免死锁。



- 尽量不要一个线程同时占用多个锁
- 多个线程加锁的顺序保持一致，比如上面的例子中，都先加A锁，再加B锁，这样就能破坏造成死锁的环路结构
- 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

### 线程活锁

活锁是一种非常有趣的情况。不知道大家是否遇到过这么一种场景，当你要坐电梯下楼时，电梯到了，门开了，这时你正准备出去。但很不巧的是，门外一个人挡着你的去路，他想进来。于是，你很礼貌地靠左走，避让对方。同时，对方也非常礼貌地靠右走，希望避让你。结果，你们俩就又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右边走，同时，他立即向左边走。结果，又撞上了！不过介于人类的智能，我相信这个动作重复两三次后，你应该可以顺利解决这个问题。因为这个时候，大家都会本能地对视，进行交流，保证这种情况不再发生。

但如果这种情况发生在两个线程之间可能就不会那么幸运了。如果线程的智力不够，且都秉承着“谦让”的原则，主动将资源释放给他人使用，那么就会导致资源不断地在两个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行。这种情况就是活锁。

### 同步和异步

这边讨论的同步和异步指的是同步方法和异步方法

#### 同步方法

同步方法是指调用这个方法后，调用方必须等到这个方法执行完成之后才能继续往下执行

#### 异步方法

异步方法是指调用这个方法后立马会返回，调用方能立马往下继续执行，被调用的异步方法其实是由另外的线程进行执行的，如果这个异步方法有返回值的话可以通过某种通知的方式告知调用方

实现异步方法的方式：

- 回调函数模式：一个方法被动调用后立马返回，调用结果通过回调函数返回给调用方
- MQ（发布/订阅）：请求方将请求发送到MQ，请求处理方监听MQ处理这些请求，并将请求处理结果也返回给某个MQ，调用方监听这个Queue获取处理结果
- 多线程处理模式：系统创建其他线程处理调用请求，比如Spring中的@Async注解标注的方法就是这种方法



### 临界区

涉及读写共享资源的代码片段叫“临界区”

比如下面代码中，1处和2处就是一个代码临界区

```
private static class BankAccount{
        String accountName;
        double balance;

        public BankAccount(String accountName,double balance){
            this.accountName = accountName;
            this.balance = balance;
        }

        public synchronized   double deposit(double amount){
            balance = balance + amount; //1
            return balance;
        }

        public synchronized  double  withdraw(double amount){
            balance = balance - amount; //2
            return balance;
        }

    }
```

### 内存可见性

在多线程下处理共享变量时Java的内存模型，如下图：

![img](E:\软件\Typora\images\v2-af520d543f0f4f205f822ec3b151ad46_720w.jpg)

Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫做工作内存，线程读写变量时操作的是自己工作内存中的变量，处理完后将变量值更新到主内存。

> 《Java并发编程之美》P54

## 并发编程基础-进阶

### Java中synchronized关键字

synchronized块是Java提供的一种原子性内置锁

（这些Java内置的使用者看不到的锁被称为内部锁，也叫做监视器锁，内置锁是排它锁）

进入synchronized块的内存语义就是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取

退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存

除可以解决共享变量内存可见性问题外，synchronized经常被用来实现原子性操作。

synchronized关键字会引起线程上下文切换并带来线程调度开销。

实例：单例模式双重校验锁

```java
Class Singleton{
    private volatile static Singleton singleton;
    
    private Singleton{
        
    }
    
    public static Singletion getInstance() {
        // 先判断对象是否已经实例化过，没有实例化过才进入加锁代码
        if (singleton == null) {
            // 类对象加锁
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
    }
}
```



### Java中volatile关键字

弱形式的同步，volatile关键字

当线程写入volatile变量值时，把写入工作内存的变量值同步到主内存

当读取volatile变量值时，先清空本地内存变量值，再从主内存获取最新值

**一般在什么时候才使用volatile关键字呢？**

- 写入变量值不依赖变量的当前值时。

  因为如果依赖当前值，将是获取——计算——写入三步操作，这三步操作不是原子性的，而volatile不保证原子性

- 读写变量值时没有加锁。

  因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为volatile的

### CAS

#### CAS简介

CAS机制是一种数据更新的方式。

CAS机制是乐观锁的典型实现。

CAS，是Compare and Swap的简称，在这个机制中有三个核心参数：

- 主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存的值）
- 工作内存中共享变量的副本值，也叫预期值：A
- 需要将共享变量更新到的最新值：B

![img](https://img2018.cnblogs.com/blog/1775037/202001/1775037-20200106164315461-658325570.jpg)

如上图，主存中保存V值，线程要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后计算B值，最后再把B值写回到内存V值中。

多个线程共用V值都是如此操作。

CAS核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值以及被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。

值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。



#### CAS方法

CAS即Compare and Swap，其是JDK提供的非阻塞原子性操作，它通过硬件保证了比较——更新操作的原子性。JDK里面的Unsafe类提供了一系列`compareAndSwap`方法。

下面以`compareAndSwapLong`方法为例进行简单介绍

- `boolean compareAndSwapLong(Object obj,long valueOffset,long expect,long update)`方法

  CAS有四个操作数，分别为：对象内存位置，对象中的变量的偏移量，变量预期值和新的值。

  其操作含义是，如果对象`obj`中内存偏移量为`valueOffset`的变量值为expect，则使用新的值update替换旧的值expect。这是处理器提供的一个原子性命令。

  

#### CAS机制优缺点

##### 缺点：

1. ABA问题

   ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一本版本号和某个值，A->B->A问题就变成了1A->2B->3A。jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。

   

2. 可能会消耗较高的CPU

   看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间，每个方法不能绝对的比另一个号，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU，因此可以看出，如果线程之间竞争程度越小，使用CAS是个很好的选择，但是如果竞争很大，使用锁可能是个更好的选择。

   

3. 不能保证代码块的原子性

   Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性（这时候就需要synchronized锁了）



##### 优点：

- 可以保证变量操作的原子性
- 并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高
- 在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会比较高

### Unsafe类

Unsafe类中的方法都是native方法

#### 如何使用Unsafe类

```
public class TestUnsafe {
    /**
     * 获取Unsafe的实例(2.2.1)
     */
    static final Unsafe unsafe = Unsafe.getUnsafe();

    /**
     * 记录变量state在类TestUnsafe中的偏移值(2.2.2)
     */
    static final long stateOffset;

    /**
     * 变量(2.2.3)
     */
    private volatile long state = 0;

    static {
        try {
            // 获取state变量在类TestUnsafe中的偏移值(2.2.4)
            stateOffset = unsafe.objectFieldOffset(TestUnsafe.class.getDeclaredField("state"));
        } catch (NoSuchFieldException e) {
            System.out.println(e.getLocalizedMessage());
            throw new Error(e);
        }
    }

    public static void main(String[] args) {
        // 创建实例 并且设置state的值为1(2.2.5)
        TestUnsafe test = new TestUnsafe();
        //(2.2.6)
        boolean success = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);
        System.out.println(success);
    }
}
```

代码(2.2.1)获取了一个Unsafe的一个实例

代码(2.2.3)创建了一个变量state并初始化为0

代码(2.2.4)使用unsafe.objectFieldOffset获取TestUnsafe类里面的state变量，在TestUnsafe对象里面的内存偏移量地址并将其保存到stateOffset变量中

(2.2.6)调用创建的unsafe实例的compareAndSwapInt方法，设置test对象的state变量的值。具体意思是，如果test对象中内存偏移量为stateOffset的state变量的值为0，则更新该值为1.

运行上面的代码，我们期望输出true，然后执行后会输出如下结果：

![image-20201210221351777](E:\软件\Typora\images\image-20201210221351777.png)

为找出原因，必然要查看getUnsafe的代码

```
private static final Unsafe theUnsafe;
    
@CallerSensitive
public static Unsafe getUnsafe() {
    //(2.2.7)
    Class localClass = Reflection.getCallerClass();
    
    //(2.2.8)
    if (!VM.isSystemDomainLoader(localClass.getClassLoader())) {
        throw new SecurityException("Unsafe");
    } else {
        return theUnsafe;
    }
}

// 判断paramClassLoader是不是Bootstrap类加载器(2.2.9)
public static boolean isSystemDomainLoader(ClassLoader paramClassLoader) {
    return paramClassLoader == null;
}
```

代码(2.2.7)获取调用这个方法的对象的Class对象，这里是`TestUnsafe,class`

代码(2.2.8)判断是不是Bootstrap类加载器加载的`localClass`，很明显`TestUnsafe.class`是使用`AppClassLoader`加载的，所以这里直接抛出了异常

思考一下，这里为何要有这个判断？

因为我们知道Unsafe类是rt.jar包提供的，rt.jar包里面的类是用Bootstrap类加载器加载的，而我们启动的main函数所在的类是使用`AppClassLoader`加载的，所以在main函数里面加载Unsafe类时，根据委托机制，会委托`BootStrap`去加载Unsafe类

如果没有代码(2.2.8)的限制，那么我们的应用程序就可以随意使用Unsafe做事情了，而Unsafe类可以直接操作内存，这是不安全的，所以JDK开发组特意做了这个限制，不让开发人员在正规渠道使用Unsafe类，而是在rt.jar包里面的核心类中使用Unsafe功能。

如果开发人员真的想要实例化Unsafe类，那该如何做？

使用万能的反射来获取Unsafe实例方法

```
public class TestUnsafe {

    static final Unsafe unsafe;

    static final long stateOffset;

    private volatile long state = 0;

    static {
        try {
            // 使用反射获取Unsafe的成员变量theUnsafe
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            // 设置为可存取
            field.setAccessible(true);
            // 获取该变量的值
            unsafe = (Unsafe) field.get(null);
            // 获取state在TestUnsafe中的偏移量
            stateOffset = unsafe.objectFieldOffset(TestUnsafe.class.getDeclaredField("state"));
        } catch (Exception e) {
            System.out.println(e.getLocalizedMessage());
            throw new Error(e);
        }
    }

    public static void main(String[] args) {
        TestUnsafe test = new TestUnsafe();
        boolean success = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);
        System.out.println(success);
    }
}
```

输出结果：

![image-20201210223013165](E:\软件\Typora\images\image-20201210223013165.png)

### 指令重排序

Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。

在单线程下重排序可以保证最终执行的结果与程序顺序执行的结果一致，但是在多线程下就会存在问题。

```
public class ReSort {
    private static int num = 0;
    private static boolean ready = false;

    public static class ReadThread extends Thread{
        @Override
        public void run() {
            while (!Thread.currentThread().isInterrupted()){
                if (ready){ //(1)
                    System.out.println(num+num); //(2)
                }
                System.out.println("read Thread...");
            }
        }
    }

    public static class WriteThread extends Thread{
        @Override
        public void run() {
            num = 2; //(3)
            ready = true;  //(4)
            System.out.println("writeThread set over...");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReadThread rt = new ReadThread();
        rt.start();

        WriteThread wt = new WriteThread();
        wt.start();

        Thread.sleep(10);
        rt.interrupt();
        System.out.println("main exit");
    }

}
```

如上代码在不考虑内存可见性问题的情况下，一定会输出4？

不一定，由于代码(1)(2)(3)(4)之间不存在依赖关系，所以写线程的代码(3)(4)可能被重排序为先执行(4)再执行(3)，那么执行(4)后，读线程可能已经执行了(1)操作，并且在(3)执行之前就开始执行(2)，这时候输出结果为0而不是4

重排序在多线程下会导致非预期的程序执行结果，而使用volatile修饰ready就可以避免重排序和内存可见性问题。

### 锁的概述

#### 乐观锁与悲观锁

悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个处理过程中，使数据处于锁定状态，悲观锁的实现往往依靠数据库的锁机制。

乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会对数据冲突与否进行检测。乐观锁并不会使用数据库提供的锁机制，一般在表中添加version字段或者使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。

#### 公平锁与非公平锁

公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁，而非公平锁则在运行时闯入，也就是先来不一定得。

ReentrantLock提供了公平和非公平锁的实现

- 公平锁：ReentrantLock pairLock = new ReentrantLock(true);
- 非公平锁：ReentrantLock pairLock = new ReentrantLock(false);

如果构造函数不传递参数，则默认是非公平锁。

在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能消耗。

#### 独占锁和共享锁

独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是以独占方式实现的。独占锁是一种悲观锁。

共享锁则可以同时由多个线程持有，例如ReentrantLock读写锁，它允许一个资源可以被多线程进行读操作。共享锁是一种乐观锁。

#### 什么是可重入锁

当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞。

那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（严格来说是有限次数）地进入被该锁锁住的代码。

可重入锁的原理是在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。

但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值+1，当释放锁后计数器值-1.当计数器值为0时，锁里面的线程标示被重置为null，这时候被阻塞的线程会被唤醒来竞争获取该锁。

#### 自旋锁

自旋锁是当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX：PreBlockSpinsh参数设置该值），如果尝试指定次数后仍没有获取到该锁则当前线程才会被阻塞挂起。

自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些CPU时间白白浪费了。

## 一些重要的类

### Thread

Thread类常用方法如下：

- `Thread.activeCount()`：这个方法用于返回当前线程的线程组中活动线程的数量，返回的值只是一个估计值，因为当此方法遍历内部数据结构时，线程数可能会动态更改。）。
- `Thread.checkAccess()`: 检验当前正在执行的线程是否有权限修改thread的属性，这个方法我们一般不自己进行调用，Thread类的set方法在进行属性修改时都会先调用这个方法。
- `Thread.currentThread()`：获取当前正在运行的线程。
- `Thread.dumpStack()`:输出线程栈，一般在debug的时候调用。
- `Thread.enumerate(Thread tarray[])`:??使用场景。
- `Thread.getAllStackTraces()`:获取系统中所有线程的线程栈信息。
- `thread.getName()`：获取线程的名字。
- `thread.getPriority()`：获取线程的优先级。
- `thread.getStackTrace()`:获取堆栈信息。
- `thread.getState()`:获取线程状态。
- `thread.getThreadGroup()`：获取线程所在线程组。
- `thread.interrupt()`：使得指定线程中断阻塞状态，并将阻塞标志位置为true。
- `thread.interrupted()`:测试当前线程是否被中断。
- `thread.isAlive()`：判断线程是否还存活着。
- `thread.isDaemon()`：判断线程是否是守护线程。
- `thread.join()`：在当前线程中加入指定线程，使得当前线程必须等待指定线程运行结束之后，才能结束。可以理解成线程插队、等待该线程终止。
- `Thread.sleep(long)`：强制线程睡眠一段时间。
- `thread.start()`：启动一个线程。
- `thread.setName(name)`：设置线程的名字。
- `thread.setPriority(priority)：设置线程的优先级。`
- `thread.setDaemon(true)`：将指定线程设置为守护线程。
- `thread.yield()`：使得当前线程退让出CPU资源，把CPU调度机会分配给同样线程优先级的线程。
- object.wait()、object.notify()、object.notifyAll()：Object类提供的线程等待和线程唤醒方法。

还有Thread类提供了功能丰富的构造函数

![img](https://img2018.cnblogs.com/blog/1775037/201912/1775037-20191206162420769-289893141.png)

示例代码

```
public class MyThread  {

    public static void main(String[] args) {
          Thread thread = Thread.currentThread();
        
                //这个方法返回的是当前线程所在线程组以及这个线程组的子线程组内活动的线程数
                //这个值是一个估计值，所以这个方法的应用场景不大
                int activeCount = Thread.activeCount();
                System.out.println("当前系统中活动线程数["+activeCount+"]");
        
                //向标准错误输出流输出当前的线程栈,不会阻断程序的继续执行
                Thread.dumpStack();
        
                //获取所有线程栈信息
                Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces();
        
                //获取类加载器
                ClassLoader contextClassLoader = thread.getContextClassLoader();
        
                //获取当前线程名字
                String threadName = thread.getName();
                System.out.println("current thread name["+threadName+"]");
        
                //获取当前线程ID
                long threadId = thread.getId();
                System.out.println("current thread id["+threadId+"]");
        
                //获取当前线程的优先级，一共有1~10总共10个优先级，这个优先级并不是在
                //所有平台都生效的
                int priority = thread.getPriority();
                System.out.println("current thread priority["+priority+"]");
        
                StackTraceElement[] stackTrace = thread.getStackTrace();
                System.out.println("-------------stackTrace info--------------");
                for (int i = 0; i < stackTrace.length; i++) {
                    StackTraceElement element = stackTrace[i];
                    System.out.println("className:["+element.getClassName()+"]");
                    System.out.println("fileName：["+element.getFileName()+"]");
                    System.out.println("line nunber：["+element.getLineNumber()+"]");
                    System.out.println("method name:["+element.getMethodName()+"]");
                    System.out.println("is native method:["+element.isNativeMethod()+"]");
                    System.out.println("------------------------------------------");
                }
        
                Thread.State state = thread.getState();
                System.out.println("thread state:["+state+"]");
        
                ThreadGroup threadGroup = thread.getThreadGroup();
                String threadGroupName = threadGroup.getName();
                System.out.println("thread group name:["+threadGroupName+"]");
        
                //线程睡眠,调用sleep方法会使得线程进入timed_waiting状态，如果线程已经
                //获得了锁资源，调用sleep方法是不会释放这个锁的
                Thread.sleep(2000,500);
                Thread.sleep(1000);
                TimeUnit.SECONDS.sleep(2);
        
                Thread thread1 = new Thread(new Runnable() {
                    @SneakyThrows
                    @Override
                    public void run() {
                        TimeUnit.SECONDS.sleep(100);
                    }
                });
                thread1.start();
                thread1.join(50);

    }
}

```

#### 等待线程执行终止的join方法

在项目实践中经常会遇到一个场景，就是需要等待某几件事完成后才能继续往下执行，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。

前面的等待通知方法是Object类中的方法，而join方法则是Thread类直接提供的，join是无参且返回值为void的方法。

```
public static void main(String[] args) throws InterruptedException {
        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("child ThreadOne over!");
            }
        });

        Thread threadTwo = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("child ThreadTwo over!");
            }
        });
        
        // 启动子线程
        threadOne.start();
        threadTwo.start();

        System.out.println("wait all child thread over!");

        // 等待子线程执行完毕，返回
        threadOne.join();
        threadTwo.join();
    }
```

如上述代码在主线程里面启动了两个子线程，然后分别调用了它们的join方法，那么主线程首先会调用`threadOne.join()`方法后被阻塞，等待`threadOne`执行完毕后返回。`threadOne`执行完毕后`threadOne.join()`就会返回，然后主线程调用`threadTwo.join()`方法后再次被阻塞，等待`threadTwo`执行完毕后返回，这里只是为了演示join方法的作用，在这种情况下使用后面会讲到的`CountDownLatch`是个不错的选择。

另外，线程A调用线程B的join方法后会被阻塞，当其他线程调用了线程A的interrupt()方法中断了线程A时，线程A会抛出`InterruptedException`异常而返回。

代码如下：

```
public static void main(String[] args) {
        // 线程One
        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("ThreadOne begin run!");
                for(;;){

                }
            }
        });

        // 获取主线程
        final Thread mainThread = Thread.currentThread();

        // 线程Two
        Thread threadTwo = new Thread(new Runnable() {
            @Override
            public void run() {
                // 休眠1s
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 中断主线程
                mainThread.interrupt();
            }
        });

        // 启动子线程
        threadOne.start();

        // 延迟1s启动线程
        threadTwo.start();

        try {
            threadOne.join();
        } catch (InterruptedException e) {
            System.out.println("main thread:" + e);
        }

    }
```

输出结果：

![image-20201208220428225](E:\软件\Typora\images\image-20201208220428225.png)

如上代码在`threadOne`线程里面执行死循环，主线程调用`threadOne`的join方法阻塞自己等待线程`threadOne`执行完毕，待`threadTwo`休眠1s后会调用主线程的interrupt()方法设置主线程的中断标志，从结果看在主线程中的`threadOne.join()`处会抛出`InterruptedException`异常。



#### 让线程睡眠的sleep方法

- Thread类中的静态方法
- 让出指定时间的执行权，但是该线程所拥有的监视器资源，比如锁还是持有不让出
- 指定时间到了正常返回，线程处于就绪状态
- 如果在睡眠期间其他线程调用了该线程的`interrupt()`方法中断了该线程，则该线程会在调用sleep方法的地方抛出`InterruptedException`异常而返回
- 如果在调用`Thread,sleep(long millis)`方法时`millis`参数传递了一个负数，则会抛出`IllegalArgumentException`异常

【线程在睡眠时拥有的监视器资源不会释放】，代码如下：

```
public class ThreadForSleep {
    /**
     * 创建一个独占锁
     */
    private static final Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        // 创建线程A
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                // 获取独占锁
                lock.lock();
                try {
                    System.out.println("child threadA is in sleep");

                    Thread.sleep(10000);

                    System.out.println("child threadA is in awake");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    // 释放锁
                    lock.unlock();
                }
            }
        });

        // 创建线程B
        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                // 获取独占锁
                lock.lock();
                try {
                    System.out.println("child threadB is in sleep");

                    Thread.sleep(10000);

                    System.out.println("child threadB is in awake");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    // 释放锁
                    lock.unlock();
                }
            }
        });

        // 启动线程
        threadA.start();
        threadB.start();
    }
}
```

输出结果：

![image-20201208221357999](E:\软件\Typora\images\image-20201208221357999.png)



#### 让出CPU执行权的yield方法

- Thread类静态方法
- 当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态
- 线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权

```
public class ThreadForYield implements Runnable {

    ThreadForYield() {
        // 创建并启动线程
        Thread t = new Thread(this);
        t.start();
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            // 当i=0时让出CPU执行权，放弃时间片，进行下一轮调度
            if ((i % 5) == 0) {
                System.out.println(Thread.currentThread() + "yield cpu...");
                // 当前线程让出CPU执行权 放弃时间片 进行下一轮调度
                //Thread.yield();
            }
        }
        System.out.println(Thread.currentThread() + "is over");

    }

    public static void main(String[] args) {
        new ThreadForYield();
        new ThreadForYield();
        new ThreadForYield();
    }
}
```

输出结果：

```
Thread[Thread-0,5,main]yield cpu...
Thread[Thread-0,5,main]is over
Thread[Thread-1,5,main]yield cpu...
Thread[Thread-1,5,main]is over
Thread[Thread-2,5,main]yield cpu...
Thread[Thread-2,5,main]is over
```

如上开启了三个线程，每个线程的功能都一样，都是在for循环中执行5次打印，运行多次后，上面的结果出现的次数是最多的。

> ==问题：=我执行了几十次，一次都没碰到过！！！====

解开`Thread.yield()`注释再执行，结果如下：

![image-20201208224053853](E:\软件\Typora\images\image-20201208224053853.png)

从结果可知，`Thread.yield()`方法生效了，三个线程分别在i=0时调用了`Thread.yield()`方法，所以三个线程自己的两行输出没有在一起，因为输出了第一行后当前线程让出了CPU执行权。

一般很少使用这个方法，在调试或者测试时这个方法或许可以帮助复现由于并发竞争条件导致的问题。



#### 线程中断

- **void interrupt()方法：中断线程**

  例如，当线程A运行时，线程B可以调用线程A的interrupt()方法来设置线程A的中断标志为true并立即返回。**调用线程类的interrupted方法，其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程状态决定是否抛出异常**

  （如果在中断时，线程正处于非阻塞状态，则将中断标志修改为true,而在此基础上，一旦进入阻塞状态，则按照阻塞状态的情况来进行处理；例如，一个线程在运行状态中，其中断标志被设置为true,则此后，一旦线程调用了wait、join、sleep方法中的一种，立马抛出一个`InterruptedException`，且中断标志被清除，重新设置为false）

  如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程B调用线程A的interrupt()方法，线程A会在调用这些方法的地方抛出`InterruptedException`异常而返回。

- **`boolean isInterrupted()`方法：检测当前线程是否被中断**

  如果是返回true，否则返回false

  **调用该方法的对象**所表示的线程，且这个方法不会清除中断状态。是实例方法（它测试的是实例对象所表示的线程的中断状态）

- **`boolean interrupted()`方法：检测当前线程是否被中断**

  如果是返回true，否则返回false。

  **当前线程**(current thread)的中断状态，且这个方法会清除中断状态。是静态方法（它测试的是当前线程的中断状态）

【使用Interrupted优雅退出】，代码如下：

```
public void run(){
      try {
      ...
          // 线程退出条件
          while (!Thread.currentThread().isInterrupted() && more work to do){
              // do more work
          }
      }catch (InterruptedException e){
          // thread was interrupted during sleep or wait
      }finally {
          // cleanup ,if required
      }
  }
```



### ThreadLocal

#### 什么是ThreadLocal

ThreadLocal有点类似于Map类型的数据变量。

`ThreadLocal`是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本，当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。

需要注意的是一个ThreadLocal变量，其中只能set一个值。

ThreadLocal源码：

```java
public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }

public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
```

可以发现每个线程中都有一个ThreadLocalMap数据结构，当执行set方法时，其值是保存在当前线程的threadLocals变量中，当执行get方法，是从当前线程的threadLocals变量获取（ThreadLocalMap的key值是ThreadLocal类型）

所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1的值，保证了线程之间不会相互干扰。

上面提到ThreadLocal的变量都是存储在ThreadLocalMap的变量中，下面给出Thread、ThreadLocal和ThreadLocalMap的关系

![img](https://img2018.cnblogs.com/blog/1775037/201911/1775037-20191111192648664-1164232306.png)

Thread类有属性变量threadLocals（类型是ThreadLocal.ThreadLocalMap)，也就是说每个线程有一个自己的ThreadLocalMap，所以每个线程往这个ThreadLocal中读写隔离，并且是互相不会影响的。一个ThreadLocal只能存储一个Object对象，如果需要存储多个Object对象那么就需要多个ThreadLocal。

#### ThreadLocal使用场景

1. 保存线程上下文信息，在任意需要的地方可以获取

   比如我们在使用SpringMVC时，想要在Service层使用HTTPServletRequest，一种方式就是在Controller层将这个变量传给Service层，但是这种写法不够优雅，Spring早就帮我们想到了这种情况，而且提供了现成的工具类

   ```java
   public static final HttpServletRequest getRequest(){
       HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
       return  request;
   }
   
   public static final HttpServletResponse getResponse(){
       HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();
       return response;
   }
   ```

   上面的代码就是使用ThreadLocal实现变量在线程各处传递的

2. 保证某些情况下的线程安全，提升性能

   性能监控，如记录一下请求的处理时间，得到一些慢请求（如请求时间超过500毫秒），从而进行性能改进。这边我们以SpringMVC的拦截器功能为例子

   ```java
   public class StopWatchHandlerInterceptor extends HandlerInterceptorAdapter {  
       //NamedThreadLocal是Spring对ThreadLocal的封装，原理一样
       //在多线程情况下，startTimeThreadLocal变量必须每个线程之间隔离
       private NamedThreadLocal<Long>  startTimeThreadLocal = new NamedThreadLocal<Long>("StopWatch-StartTime");  
       @Override  
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) throws Exception {  
           //1、开始时间
           long beginTime = System.currentTimeMillis();  
           //线程绑定变量（该数据只有当前请求的线程可见）  
           startTimeThreadLocal.set(beginTime);
           //继续流程  
           return true;
       }  
         
       @Override  
       public void afterCompletion(HttpServletRequest request, HttpServletResponse response,Object handler, Exception ex) throws Exception {  
           long endTime = System.currentTimeMillis();//2、结束时间  
           long beginTime = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间）  
           long consumeTime = endTime - beginTime;//3、消耗的时间  
           if(consumeTime > 500) {//此处认为处理时间超过500毫秒的请求为慢请求  
           //TODO 记录到日志文件  
           System.out.println(String.format("%s consume %d millis", request.getRequestURI(), consumeTime));  
           }          
       }  
   }  
   
   ```

   说明：其实要实现上面的功能，完全可以不用ThreadLocal（同步锁等），但是上面的代码的确是说明ThreadLocal这个使用场景很好的例子。



#### `ThreadLocal`使用示例

```java
public class ThreadLocalTest {

    /**
     * 打印函数
     * @param str
     */
    static void print(String str){
        System.out.println(str + ":" + localVariable.get());
        //localVariable.remove();
    }

    /**
     * 创建ThreadLocal变量
     */
    static ThreadLocal<String> localVariable = new ThreadLocal<>();

    public static void main(String[] args) {
        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                localVariable.set("threadOne local variable");
                print("threadOne");
                System.out.println("threadOne remove after" + ":" +localVariable.get());
            }
        });

        Thread threadTwo = new Thread(new Runnable() {
            @Override
            public void run() {
                localVariable.set("threadTwo local variable");
                print("threadTwo");
                System.out.println("threadTwo remove after" + ":" +localVariable.get());
            }
        });

        threadOne.start();
        threadTwo.start();
    }
输出结果：
```



![image-20201209220730031](E:\软件\Typora\images\image-20201209220730031.png)

打开`//localVariable.remove();`注释

输出结果：

![image-20201209220830278](E:\软件\Typora\images\image-20201209220830278.png)																													

#### `ThreadLocal`的实现原理

在每个线程内部都有一个名为`threadLocals`的成员变量，该变量的类型为`HashMap`，其中key为我们定义的`ThreadLocal`变量的this引用，value则为我们使用set方法设置的值。

每个线程的本地变量存放在自己的内存变量`threadLocals`中，如果当前线程一直不消亡，那么这些本地变量会一直存在，所以可能会造成内存溢出，因此使用完毕之后要记得调用`ThreadLocal`的remove方法删除对应线程的`threadLocals`中的本地变量。

#### `ThreadLocal`不支持继承性

同一个`ThreadLocal`变量在父线程中被设置值后，在子线程中是获取不到的。

那么有没有办法让子线程能访问到父线程中的值？有

#### `InheritableThreadLocal`类

```
public class InheritableThreadLocal<T> extends ThreadLocal<T> {
    (1)
    protected T childValue(T parentValue) {
        return parentValue;
    }

    (2)
    ThreadLocalMap getMap(Thread t) {
       return t.inheritableThreadLocals;
    }

   (3)
    void createMap(Thread t, T firstValue) {
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
    }
}

```

`InheritableThreadLocal`继承了`ThreadLocal`，并重写了三个方法。、

`InheritableThreadLocal`类通过重写代码(2)和(3)让本地变量保存到了具体线程的`inheritableThreadLocals`变量里面，那么线程在通过`InheritableThreadLocal`类实例的set或者get方法设置变量时，就会创建当前线程的`inheritableThreadLocals`变量

当父线程创建子线程时，构造函数会把父线程中`inheritableThreadLocals`变量里面的本地变量复制一份保存到子线程的`inheritableThreadLocals`变量里面

那么什么情况下需要子线程可以获取父线程的`threadLocal`变量呢？

- 子线程需要使用存放在`threadLocal`变量中的用户登录信息
- 一些中间件需要把统一的id追踪的整个链路记录下来

### ThreadLocalRandom

`ThreadLocalRandom`类是JDK7在JUC包下新增的随机数生成器，它弥补了Random类在多线程下的缺陷。

#### Random类及其局限性

【`java.util.Random`的使用方法】，代码如下：

```
public class RandomTest {
    public static void main(String[] args) {
        // 创建一个默认种子的随机数生成器
        Random random = new Random();
        // 输出10个在0~5（包含0，不包含5）之间的随机数
        for (int i = 0; i < 10; ++i) {
            System.out.println(random.nextInt(5));
        }
    }
}
```

随机数的生成需要一个默认的种子，这个种子其实是一个long类型的数字，你可以在创建Random对象时通过构造函数指定，如果不指定则在默认构造函数内部生成一个默认的值。有了默认的种子后，如何生成随机数呢？

```java
    public int nextInt(int bound) {
        // 参数检查
        if (bound <= 0)
            throw new IllegalArgumentException(BadBound);
       
        // 根据老的种子生成新的种子
        int r = next(31);
        int m = bound - 1;
        
        // 根据新的种子计算随机数
        if ((bound & m) == 0)  
            r = (int)((bound * (long)r) >> 31);
        else {
            for (int u = r;
                 u - (r = u % bound) + m < 0;
                 u = next(31))
                ;
        }
        return r;
    }
```

```java
protected int next(int bits) {
    long oldseed, nextseed;
    AtomicLong seed = this.seed;
    do {
        oldseed = seed.get();
        //根据旧值计算新的种子
        nextseed = (oldseed * multiplier + addend) & mask;
    } while (!seed.compareAndSet(oldseed, nextseed));
    return (int)(nextseed >>> (48 - bits));
}
```

由此可见，新的随机数生成需要两个步骤：

- 首先根据老的种子生成新的种子
- 然后根据新的种子来计算新的随机数

**在每个Random实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原来原子变量。在多线程下使用单个Random实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新时CAS操作，同时只会有一个线程会成功，所以会造成大量线程进行自旋重试，这会降低并发性能，所以`ThreadLocalRandom`应运而生。**

#### `ThreadLocalRandom`

【`ThreadLocalRandom`如何使用】，代码如下：

```java
public class RandomTest {
    public static void main(String[] args) {
        // 获取一个随机数生成器
        ThreadLocalRandom random = ThreadLocalRandom.current();
        // 输出10个0-5（包含0，不包含5）之间随机数
        for (int i = 0; i < 10; i++) {
            System.out.println(random.nextInt(5));
        }
    }
}
```

`ThreadLocal`通过让每个线程复制一份变量，使得在每个线程对变量进行操作时实际是操作自己本地内存里面的副本，从而避免了对共享变量进行同步。实际上`ThreadLocalRandom`的实现也是这个原理。

Random的缺点是多个线程会使用同一个原子性种子变量，从而导致对原子变量更新的竞争。

那么如果每个线程都维护一个种子变量，则每个线程生成随机数时都根据自己老的种子计算新的种子，并使用新的种子更新老的种子，再根据新种子计算随机数，就不会存在竞争问题了，这会大大提高并发性能。

#### 源码分析

`ThreadLocalRandom`类继承了Random类并重写了`nextInt`方法。

在`ThreadLocalRandom`中并没有存放具体的种子，具体的种子存放在具体调用线程`threadLocalRandomSeed`变量里面。

![img](https://img2018.cnblogs.com/blog/1775037/202002/1775037-20200211143247739-1771064494.png)

`ThreadLocalRandom`类似于`ThreadLocal`类，就是个工具类。

当线程调用`ThreadLocalRandom`的current方法时，`ThreadLocalRandom`负责初始化调用线程的`threadLocalRandomSeed`变量，也就是初始化种子。

`ThreadLocalRandom`的实例里面只包含与线程无关的通用算法，所以它是线程安全的。

#### 总结

`ThreadLocalRandom`使用`ThreadLocal`的原理，让每个线程都持有一个本地的种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下计算新种子时是根据自己线程内维护的种子变量进行更新，从而避免了竞争。

## JMM相关

### Java内存模型

JMM是内存模型在JVM中的体现。

这个模型的主要目标是定义程序中各个共享变量的访问规则，也就是在虚拟机中将变量存储到内存以及从内存中取出变量这类的底层细节。

通过这些规则来规范对内存的读写操作，保证了并发场景下的可见性、原子性和有序性。

JMM作用于工作内存和主存之间数据同步过程。

他规定了如何做数据同步以及什么时候做数据同步。

也就是说Java线程之间的通信由JMM控制，JMM决定一个线程对共享变量的写入，何时对另一个线程可见。

![img](https://img2018.cnblogs.com/blog/1775037/201912/1775037-20191223140827610-1136016478.png)



#### 原子性问题

**原子性是指一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。**

在Java中当我们讨论一个操作具有原子性问题一般就是指这个操作会被线程的随机调度打断。

【下面就是一段会出现原子性问题的代码】

```
public class AtomicProblem {

    private static Logger logger = LoggerFactory.getLogger(AtomicProblem.class);
    public static final int THREAD_COUNT = 10;

    public static void main(String[] args) throws Exception {
        BankAccount  sharedAccount = new BankAccount("account-csx",0.00);
        ArrayList<Thread> threads = new ArrayList<>();
        for (int i = 0; i < THREAD_COUNT; i++) {
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000 ; j++) {
                        sharedAccount.deposit(10.00);
                    }
                }
            });
            thread.start();
            threads.add(thread);
        }
        for (Thread thread : threads) {
            thread.join();
        }
        logger.info("the balance is:{}",sharedAccount.getBalance());
    }


    public static class BankAccount {
        private String accountName;

        public double getBalance() {
            return balance;
        }

        private double balance;

        public BankAccount(String accountName, double balance){
            this.accountName = accountName;
            this.balance =balance;
        }
        public double deposit(double amount){
            balance = balance + amount;
            return balance;
        }
        public double withdraw(double amount){
            balance = balance - amount;
            return balance;
        }
        public String getAccountName() {
            return accountName;
        }
        public void setAccountName(String accountName) {
            this.accountName = accountName;
        }
    }
}
```

上面的代码中开启了10个线程，每个线程会对共享的银行账户进行1000次存款操作，每次存款10块，所以理论上最后银行账户中的钱应该是10 * 1000 * 10 = 100000块。我执行了多次上面的代码，很多次最后的结果的确是100000，但是也有几次的结果并不是我们预期的。

```
Copy14:40:25.981 [main] INFO com.csx.demo.spring.boot.concurrent.jmm.AtomicProblem - the balance is:98260.0
```

出现上面结果的原因就是因为下面的操作并不是原子操作，其中的`balance`是一个共享变量。在多线程环境下可能会被打断。

```
balance = balance + amount;
```

上面的赋值操作被分为多步执行完成，下面简单解析下两个线程对`balance`同时加10的过程（模拟存款过程，假设balance的初始值还是0）

```
线程1从共享内存中加载balance的初始值0到工作内存
线程1对工作内存中的值加10

//此时线程1的CPU时间耗尽，线程2获得执行机会

线程2从共享内存中加载balance的初始值到工作内存，此时balance的值还是0
线程2对工作内存中的值加10，此时线程2工作内存中的副本值是10
线程2将balance的副本值刷新回共享内存，此时共享内存中balance的值是10

//线程2CPU时间片耗尽，线程1又获得执行机会
线程1将工作内存中的副本值刷新回共享内存，但是此时副本的值还是10，所以最后共享内存中的值也是10
```

上面简单模拟了一个原子性问题导致程序最终结果出错的过程。

##### JMM对原子性问题的保证

###### **自带原子性保证**

在Java中，对 **基本数据类型的变量的读取和赋值操作**是原子性操作（例外就是long和double的非原子性协定，大家只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）

```
a = true;  //原子性
a = 5;     //原子性
a = b;     //非原子性，分两步完成，第一步加载b的值，第二步将b赋值给a
a = b + 2; //非原子性，分三步完成
a ++;      //非原子性，分三步完成
```



###### **synchronized**

synchronized可以保证操作结果的原子性。synchronized保证原子性的原理也很简单，因为synchronized可以防止多个线程并发执行一段代码。还是用上面存款的场景做列子，我们只需要将存款的方法设置成synchronized的就能保证原子性了。

```
 public synchronized double getBalance() {
            return balance;
        }

 public synchronized double deposit(double amount){
     balance = balance + amount; //1
     return balance;
 }
```

加了synchronized后，当一个线程没执行完`deposit`这个方法前，其他线程是不能执行这段代码的。其实我们发现synchronized并不能将上面的代码1编程原子性操作，上面的代码1还是有可能被中断的，但是即使被中断了其他线程也不能访问共享变量`balance`，当之前被中断的线程继续执行时得到的结果还是正确的。

**因此synchronized对原子性问题的保证是从最终结果上来保证的，也就是说它只保证最终的结果正确，中间操作的是否被打断没法保证。这个和CAS操作需要对比着看。**

PS：对于上面的`getBalance`方法大家可能会有点疑惑：只读操作为什么还要加上synchronized关键字。其实这边加上synchronized关键字的目的是为了保证balance变量的可见性，进入synchronized代码块每次都会去从主内存中读取最新值。



###### **Lock锁**

```
public double deposit(double amount) {
    readWriteLock.writeLock().lock();
    try {
        balance = balance + amount;
        return balance;
    } finally {
        readWriteLock.writeLock().unlock();
    }
}
```

Lock锁保证原子性的原理和synchronized类似，这边不进行赘述了。



###### 原子操作类型

```
public static class BankAccount {
    //省略其他代码
    private AtomicDouble balance;

    public double deposit(double amount) {
        return balance.addAndGet(amount);
    }
    //省略其他代码
} 
```

原子操作类的底层是使用CAS机制的，这个机制对原子性的保证和synchronized有本质的区别。

CAS机制保证了整个赋值操作是原子的不能被打断的，而synchronized值能保证代码最后执行结果的正确性，也就是说synchronized能消除原子性问题对代码最后执行结果的影响。

> PS：JVM中的CAS操作是利用处理器提供的CMPXCHG指令实现的。



#### 可见性问题

##### 什么是可见性问题

```
public class VolatileDemo {

    boolean started = false;

    public void startSystem(){
        System.out.println(Thread.currentThread().getName()+" begin to start system, time:"+System.currentTimeMillis());
        started = true;
        System.out.println(Thread.currentThread().getName()+" success to start system, time:"+System.currentTimeMillis());
    }

    public void checkStartes(){
        if (started){
            System.out.println("system is running, time:"+System.currentTimeMillis());
        }else {
            System.out.println("system is not running, time:"+System.currentTimeMillis());
        }
    }

    public static void main(String[] args) {
        VolatileDemo demo = new VolatileDemo();
        Thread startThread = new Thread(new Runnable() {
            @Override
            public void run() {
                demo.startSystem();
            }
        });
        startThread.setName("start-Thread");

        Thread checkThread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true){
                    demo.checkStartes();
                }
            }
        });
        checkThread.setName("check-Thread");
        startThread.start();
        checkThread.start();
    }

}

```

上面的例子中，一个线程来改变started的状态，另外一个线程不停地来检测started的状态，如果是true就输出系统启动，如果是false就输出系统未启动。

那么当start-Thread线程将状态改成true后，check-Thread线程在执行时是否能立即看到这个变化呢？

答案是不一定能立即看到。

这边我做了很多测试，大多数情况下是能“感知”到started这个变量的变化的。

但是偶尔会存在感知不到的情况。

请看下面的日志记录：

```
start-Thread begin to start system, time:1577079553515
start-Thread success to start system, time:1577079553516  
system is not running, time:1577079553516   ==>此处start-Thread线程已经将状态设置成true,但是check-Thread线程还是没检测到
system is running, time:1577079553516
system is running, time:1577079553516
system is running, time:1577079553516
system is running, time:1577079553516
system is running, time:1577079553516
system is running, time:1577079553516
system is running, time:1577079553517
system is running, time:1577079553517
system is running, time:1577079553517
system is running, time:1577079553517
system is running, time:1577079553517
system is running, time:1577079553517
system is running, time:1577079553517
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
system is running, time:1577079553519
```

上面的现象可能会让人比较困惑，为什么有时候`check-Thread`线程能感知到状态的变化，有时候又感知不到变化呢？这个现象就是在多核CPU多线程编程环境下会出现的可见性问题。

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程在工作内存中保存的值是主内存中值的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。等到线程对变量操作完毕之后会将变量的最新值刷新回到主内存。

但是何时刷新这个最新值又是随机的。**所以就有可能一个线程已经将一个共享变量更新了，但是还没刷新回主内存，那么这时其他对这个变量进行读写的线程就看不到这个最新值。（还有一种可能就是虽然修改线程已经将最新值刷新到主内存中去了，但是读线程的工作内存中副本的缓存值还没过期，那么读线程还是会使用这个副本值，而不是主内存中的最新值）**这个就是多CPU多线程编程环境下的可见性问题。也是上面代码会出现问题的原因。



##### JMM对可见性问题的保证

###### volatile

使用volatile关键字修饰一个变量可以保证变量的可见性。所以对于上面的代码，我们只需要简单的修改下代码就可以让程序正确运行了。

```java
Copyprivate volatile boolean started = false;
```

使用volatile修饰一个共享变量可以达到如下的效果：

- 一旦线程对这个共享变量的副本做了修改，会立马刷新最新值到主内存中去；
- 一旦线程对这个共享变量的副本做了修改，其他线程中对这个共享变量拷贝的副本值会失效，其他线程如果需要对这个共享变量进行读写，必须重新从主内存中加载。

那么volatile具体是怎么达到上面两个效果的呢？其实volatile底层使用的是内存屏障来保证可见性的。

> 内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。



> 语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。

对内存屏障做下简单总结：

- 内存屏障是一个指令级别的同步点
- 内存屏障之前的写操作都必须立马刷新回主内存
- 内存屏障之后的读操作都必须从主内存中读取最新值
- 在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序，即在执行到内存屏障这句指令时，在它前面的操作已经全部完成



###### synchronized

使用synchronized代码块或者synchronized方法也可以保证共享变量的可见性。只要如下修改上面的代码，我们就能得到正确的执行结果。

```java
public synchronized void startSystem(){
    System.out.println(Thread.currentThread().getName()+" begin to start system, time:"+System.currentTimeMillis());
    value = 2;
    started = true;
    System.out.println(Thread.currentThread().getName()+" success to start system, time:"+System.currentTimeMillis());
}

public synchronized void checkStartes(){
    if (started){
        System.out.println("system is running, time:"+System.currentTimeMillis());
    }else {
        System.out.println("system is not running, time:"+System.currentTimeMillis());
    }
}
```

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。我们发现锁具有和volatile一致的内存语义，所以使用synchronized也可以实现共享变量的可见性。



###### Lock

使用Lock相关的实现类也可以保证共享变量的可见性。其实现原理和synchronized的实现原理类似，这边也就不再赘述了。



###### CAS（Atomic类）

使用原子操作类也可以保证共享变量操作的可见性。所以我们只要如下修稿上面的代码就行了。

```java
Copyprivate AtomicBoolean started = new AtomicBoolean(false);
```

原子操作类底层使用的是CAS机制。Java中CAS机制每次都会从主内存中获取最新值进行compare,比较一致之后才会将新值set到主内存中去。而且这个整个操作是一个原子操作。所以CAS操作每次拿到的都是主内存中的最新值，每次set的值也会立即写到主内存中。



#### 有序性问题

##### 指令重排

指令重排是指编译器和处理器在不影响单线程执行结果的前提下，对源代码的指令进行重新排序执行。

这种重排序执行是一种优化手段，目的是为了处理器内部的运算单元能尽量被充分利用，提升程序的整体运行效率。

重排序分为以下几种：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

![img](https://img2018.cnblogs.com/blog/1775037/201912/1775037-20191230154830181-1936285080.jpg)

通过指令重排的定义可以看出：指令重排只能保证单线程执行下的正确性，在多线程环境下，指令重排会带来一定的问题（指令重排带来性能提升的同时也增加了编程的复杂性）。

【指令重排是怎么影响程序执行结果的】

```
public class Demo {

    int value = 1;
    private boolean started = false;

    public void startSystem(){
        System.out.println(Thread.currentThread().getName()+" begin to start system, time:"+System.currentTimeMillis());
        value = 2;
        started = true;
        System.out.println(Thread.currentThread().getName()+" success to start system, time:"+System.currentTimeMillis());
    }

    public void checkStartes(){
        if (started){
            //关注点
            int var = value+1;  
            System.out.println("system is running, time:"+System.currentTimeMillis());
        }else {
            System.out.println("system is not running, time:"+System.currentTimeMillis());
        }
    }
}
```

对于上面的代码，假如我们开启一个线程调用`startSystem`,再开启一个线程不断调用`checkStartes`方法，我们并不能保证代码执行到“关注点”处，var变量的值一定是3。因为在startSystem方法中的两个赋值语句并不存在依赖关系，所以在编译器进行代码编译时可能进行指令重排。所以真实的执行顺序可能是下面这样的。

```java
Copystarted = true;
value = 2;
```

也就是先执行`started = true;`执行完这个语句后，线程立马执行checkStartes方法，此时value值还是1，那么最后在关注点处的var值就是2，而不是我们想象中的3。



##### 重排序的原则

处理器为了提升程序的性能，可以对程序进行重排序。但是必须满足重排序之后的代码在单线程环境下执行的结果不能改变。这个原则也就是我们常说的as-if-serial语义。

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

```java
Copydouble pi = 3.14; // A
double r = 1.0; // B
double area = pi * r * r; // C
```

上面的代码中，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。因此这段代码可能存在下面两种执行顺序

![img](https://img2020.cnblogs.com/blog/1775037/202004/1775037-20200427215456586-431226552.png)

as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。

但是像上面的例子中说的一样，在多线程环境下as-if-serial语义并不能保证程序的正确性。在多线程环境下，如果我们想要消除指令重排序给程序带来的影响，我们就要采取相应的同步措施了。



##### JVM对有序性的保证

有序性定义：**即程序执行的顺序按照代码的先后顺序执行**。

在JMM中，提供了以下三种方式来保证有序性：

- happens-before原则
- synchronized机制
- volatile机制



###### happens-before原则

happens-before原则是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生与操作B，其实就是说在发送操作B之前，操作A产生的影响能被操作B观察到。

影响包括修改内存中共享变量的值，发送了消息，调用了方法等、

> 《并发编程的艺术》中的定义如下：
>
> 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens- before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前

下面是Java内存模型下一些天然的先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。

如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序：

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
- 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
- volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
- 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、 Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

这边举个例子来帮助理解happens-before原则：

```
private int value=0；
pubilc void setValue（int value）{
    this.value=value；
}
public int getValue（）{
    return value；
}
```

假设有两个线程A和B，线程A先（在时间上先）调用了这个对象的setValue(1)，接着线程B调用getValue方法，那么B的返回值是多少？

对照着hp原则，上面的操作不满足下面的任何条件：

- 不是同一个线程，所以不涉及程序次序规则
- 不涉及同步，所以不涉及管程锁定规则
- 没有volatile关键字，所以不涉及volatile变量规则
- 没有线程的启动中断终止，所以不涉及线程启动，终止，中断规则
- 没有对象的创建与终结，所以不涉及对象终结原则
- 更没有涉及到传递性

所以一条规则都不满足，尽管线程A在时间上与线程B具有先后顺序，但是，却并不满足hp原则，也就是有序性并不会保证，所以线程B的数据获取时不安全的

时间先后顺序与先行发生原则之间基本没有太大关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。

只有真正满足了happens-before原则，才能保证线程安全。

如果不能满足happens-before原则，就需要使用下面的synchronized机制和volatile机制来保证有序性



###### synchronized

synchronized保证有序性的原理很好理解。因为synchronized可以保证同一时间只有线程能访问代码块，而在单线程环境下，JMM能天然保证代码的串行语义。

虽然说使用synchronized的代码块，还是可能发生指令重排，但是因为synchronized可以保证只有一个线程执行，所以最后的执行结果还是正确的。



###### volatile

volatile底层是使用内存屏障来保证有序性的。

写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。

读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。

> 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
> 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
> 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

内存屏障有两个能力：

- 就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的有序性
- 强制把写缓冲区/高速缓冲中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的可见性

#### 简单总结

| 特性   | volatile关键字 | synchronized关键字 | Lock接口 | Atomic变量 |
| ------ | -------------- | ------------------ | -------- | ---------- |
| 原子性 | 无法保障       | 可以保障           | 可以保障 | 可以保障   |
| 可见性 | 可以保障       | 可以保障           | 可以保障 | 可以保障   |
| 有序性 | 一定程度保障   | 可以保障           | 可以保障 | 无法保障   |

### volatile

- volatile是Java提供的一种轻量级同步机制，可以保证共享变量的可见性和有序性（禁止指令重排），volatile的实现原理是基于处理器的Lock指令的，这个指令会使得对变量的修改立马刷新回主内存，同时使得其他CPU中这个变量的副本失效

- volatile对于单个的共享变量的读/写（比如a=1这种操作）具有原子性，但是像num++或者a=b这种复合操作，volatile无法保证其原子性

- volatile的使用场景不是很多，使用时需要深入考虑下当前场景是否适用volatile（记住“对变量的写操作不依赖于当前值”、“该变量没有包含在具有其他变量的不变式中”这两个使用条件“）。

  常见的使用场景有多线程下的状态标记量和双重检查等



# 高级篇



## Atomic

JUC包提供的一系列的原子性操作类，都是使用非阻塞算法CAS实现的，相比使用锁实现原子性操作这在性能上有很大提高。

### 原子变量操作类

AtomicLong是原子性递增或递减类，其内部使用Unsafe类来实现。

```java
public class AtomicLong extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 1927816293512124184L;

    // 获取Unsafe实例(AtomicLong类就是通过BootStrap类加载器进行加载的，所以可以获取到Unsafe类的实例)
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    
    // 存放变量value的偏移值
    private static final long valueOffset;

    // 判断JVM是否支持Long类型无锁CAS
    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();
    private static native boolean VMSupportsCS8();

    static {
        try {
            // 获取value在AtomicLong中的偏移量
            valueOffset = unsafe.objectFieldOffset
                (AtomicLong.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    // 实际变量值（声明为volatile，保证内存可见性，value是具体存放计数的变量）
    private volatile long value;

   
    public AtomicLong(long initialValue) {
        value = initialValue;
    }
    ...
}

```

下面重点看下`AtomicLong`中的主要函数：

1. **递增和递减操作代码**

   ```
   // 调用unsafe方法，原子性设置value值为原始值+1，返回值为递增后的值
   public final long incrementAndGet() {
     return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;
   }
   
   // 调用unsafe方法，原子性设置value值为原始值-1，返回值为递减后的值
   public final long decrementAndGet() {
     return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L;
   }
   
   // 调用unsafe方法，原子性设置value值为原始值+1，返回值为原始值
   public final long getAndIncrement() {
     return unsafe.getAndAddLong(this, valueOffset, 1L);
   }
   
   // 调用unsafe方法，原子性设置value值为原始值-1，返回值为原始值
   public final long getAndDecrement() {
     return unsafe.getAndAddLong(this, valueOffset, -1L);
   }
   ```

   在如上代码内部都是通过调用Unsafe的`getAndAddLong`方法来实现操作，这个函数是个原子性操作，这里第一个参数是`AtomicLong`实例的引用，第二个参数是value变量在`AtomicLong`中的偏移值，第三个参数是要设置的第二个变量的值。

   其中，`getAndIncrement`方法在JDK7中的实现逻辑是：

   ```
   public final long getAndIncrement(){
     while(true){
       long current = get();
       long next = current + 1;
       if(compareAndSet(current, next))
         return current;
     }
   }
   ```

   在如上代码中，每个线程是先拿到变量的当前值（由于value是volatile变量，所以这里拿到的最新的值），然后在工作内存中对其进行+1操作，而后使用CAS修改变量的值，如果设置失败，则循环继续尝试，直到设置成功为止。

   而JDK8中的逻辑为：

   ```
   public final long getAndIncrement(){
     return unsafe.getAndAddLong(this, valueOffset, 1L);
   }
   ```

   其中JDK8中`unsafe.getAndAddLong`的代码为：

   ```
   public final long getAndAddLong(Object paramObject, long paramLong1, long paramLong2){
     long l;
     do{
       l = getLongVolatile(paramObject, paramLong1);
     }while(!compareAndSwapLong(paramObject, paramLong1, 1, 1 + paramLong2));
     return 1;
   }
   ```

   可以看到JDK7的`AtomicLong`中的循环逻辑已经被JDK8中的原子操作类Unsafe内置了，之所以内置应该是考虑到这个函数在其他地方也会用到，而内置可以提高复用性。

2. **`boolean compareAndSet(long expect, long update)`方法**

   ```
   public final boolean compareAndSet(long expect, long update) {
     return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
   }
   ```

   由如上代码克制，在内部还是调用了`unsafe.compareAndSwapLong`方法。如果原子变量中的value值等于expect，则使用update更新该值并返回TRUE，否则返回false。

   下面通过一个多线程使用【`AtomicLong`统计0的个数】的例子来加深对`AtomicLong`的理解，代码如下

   ```java
   public class Atomic {
       /**
        * 创建Long型原子计数器
        */
       private static AtomicLong atomicLong = new AtomicLong();
       /**
        * 创建数据源
        */
       private static Integer[] arrayOne = new Integer[]{0,1,2,3,0,5,6,0,56,0};
       private static Integer[] arrayTwo = new Integer[]{10,1,2,3,0,5,6,0,56,0};
   
       public static void main(String[] args) throws InterruptedException {
           // 线程one统计数组arrayOne中0的个数
           Thread threadOne = new Thread(new Runnable() {
               @Override
               public void run() {
                   int size = arrayOne.length;
                   for (int i = 0; i < size; i++) {
                       if (arrayOne[i].intValue() == 0){
                           atomicLong.incrementAndGet();
                       }
                   }
               }
           });
   
           // 线程two统计数组arrayTwo中0的个数
           Thread threadTwo = new Thread(new Runnable() {
               @Override
               public void run() {
                   int size = arrayTwo.length;
                   for (int i = 0; i < size; i++) {
                       if (arrayTwo[i].intValue() == 0){
                           atomicLong.incrementAndGet();
                       }
                   }
               }
           });
   
           threadOne.start();
           threadTwo.start();
   
           threadOne.join();
           threadTwo.join();
   
           System.out.println("count 0:" + atomicLong.get());
       }
   }
   ```

   输出结果：

   ![image-20201213171704825](E:\软件\Typora\images\image-20201213171704825.png)

   在没有原子类的情况下，实现计数器需要使用一定的同步措施，比如使用synchronized关键字等，但这些都是阻塞算法，对性能有一定损耗，而本章介绍的这些原子操作类都使用CAS算法，性能更好。但是在高并发情况下`AtomicLong`还会存在性能问题，JDK8提供了一个在高并发下性能更好的`LongAdder`类。

   ## JDK8小新增的原子操作类`LongAdder`

   ### `LongAdder`简单介绍

   使用`AtomicLong`时，在高并发下大量线程会同时去竞争更新一个原子变量，但是由于同时只有一个线程的CAS操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS的操作，而这会白白浪费CPU资源。

   因此JDK8新增了一个原子性递增递减类`LongAdder`用来克服在高并发下使用`AtomicLong`的缺点。

   ![img](E:\软件\Typora\images\20200105170054240.png)

   使用`LongAdder`时，则是在内部维护多个cell变量，每个cell里面有一个初始值为0的long型变量，这样，在同等并发量的情况下，争夺单个变量更新操作的线程量会减少，这变相的减少了争夺共享资源的并发量。

   另外，多个线程在争夺同一个Cell原子变量失败了，它不是在当前Cell变量上一直自旋CAS重试，而是尝试在其他Cell的变量上进行CAS尝试，这个改变增加了当前线程重试CAS成功的可能性。

   最后，在获取`LongAdder`当前值时，是把所有Cell变量的value值累加后再加上base返回的。

   `LongAdder`维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的`hashcode`值的掩码表示，数组里面的变量实体是Cell类型。

   Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是伪共享。所以这在性能上是一个提升。

   另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。

### `LongAdder`代码分析

`LongAdder`类图：

![img](E:\软件\Typora\images\20200105170951382.png)

`LongAdder`继承自Striped64类，在Striped64内部维护着三个变量。

`LongAdder`的真实值其实是base值与Cell数组里面所有Cell元素中的value值的累加，base是个基础值，默认为0。cellBusy用来实现自旋锁，状态只有0和1，当创建Cell元素，扩容Cell数组或者进行初始化Cell数字时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。

下面看Cell的构造：

```
@sun.misc.Contended static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }

        // Unsafe mechanics
        private static final sun.misc.Unsafe UNSAFE;
        private static final long valueOffset;
        static {
            try {
                UNSAFE = sun.misc.Unsafe.getUnsafe();
                Class<?> ak = Cell.class;
                valueOffset = UNSAFE.objectFieldOffset
                    (ak.getDeclaredField("value"));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }
```

可以看到Cell的构造很简单，其内部维护一个呗声明为volatile的变量，这里声明为volatile是因为线程操作value变量时没有用锁，为了保证变量的内存可见性这里将其声明为volatile的。另外`cas`函数通过CAS操作，保证了当前线程更新时被分配的Cell元素中value值的原子性。另外，Cell类使用`@sun.misc.Contended`修饰是为了避免伪共享。

- long sum()返回当前的值，内部操作是累积所有Cell内部的value值再累加base。例如下面的代码，由于计算总和时没有对Cell数组进行加锁，所以在累加过程中可能有其他线程对Cell中的值进行了修改，也有可能对数组进行了扩容，所以sum返回的值挺不是非常精确的，其返回值并不是一个覅有sum方法时的原子快照值。

  ```
  public long sum() {
          Cell[] as = cells; Cell a;
          long sum = base;
          if (as != null) {
              for (int i = 0; i < as.length; ++i) {
                  if ((a = as[i]) != null)
                      sum += a.value;
              }
          }
          return sum;
      }
  ```

- void reset()为重置操作，如下代码把base置为0，如果Cell数组有元素，则元素的值被重置为0

  ```
  public void reset() {
          Cell[] as = cells; 
          Cell a;
          base = 0L;
          if (as != null) {
              for (int i = 0; i < as.length; ++i) {
                  if ((a = as[i]) != null)
                      a.value = 0L;
              }
          }
      }
  ```

- `long sumThenReset()`是sum的改造版本，如下代码在使用sum累加对应的Cell值后，把当前Cell的值重置为0，base重置为0.这样，当多线程在调用该方法时会有问题，比如考虑第一个调用线程清空Cell的值，则后一个线程调用时累加的都是0值。

  ```
  public long sumThenReset() {
          Cell[] as = cells; 
          Cell a;
          long sum = base;
          base = 0L;
          if (as != null) {
              for (int i = 0; i < as.length; ++i) {
                  if ((a = as[i]) != null) {
                      sum += a.value;
                      a.value = 0L;
                  }
              }
          }
          return sum;
      }
  ```

- `void add(long x)`

  ```
  public void add(long x) {
          Cell[] as; long b, v; int m; Cell a;
          
          // 首先看cells是否为null，如果为null则当前在基础变量base上进行累加，这时候就类似AtomicLong操作
          if ((as = cells) != null || !casBase(b = base, b + x)) {
              boolean uncontended = true;
              
              // 如果cells不为null或者线程执行CAS操作失败了，获取当前线程应该访问的cells数组的Cell元素
              if (as == null || (m = as.length - 1) < 0 ||
                  (a = as[getProbe() & m]) == null ||
                  !(uncontended = a.cas(v = a.value, v + x)))
                  longAccumulate(x, null, uncontended);
          }
      }
  ```

### `LongAccumulator`类原理探究

`LongAdder`类是`LongAccumulator`的一个特例，`LongAccumulator`比`LongAdder`的功能更强大。

例如，下面的构造函数，其中`accumulatorFunction`是一个双目运算器接口，其根据输入的两个参数返回一个计算值，identity则是`LongAccumulator`累加器的初始值。

```
public LongAccumulator(LongBinaryOperator accumulatorFunction,
                           long identity) {
        this.function = accumulatorFunction;
        base = this.identity = identity;
    }
    
@FunctionalInterface
public interface LongBinaryOperator {
    // 根据两个参数计算并返回一个值
    long applyAsLong(long left, long right);
}
```

上面提到，`LongAdder`其实是`LongAccumulator`的一个特例，调用`LongAdder`就相当于使用下面的方式调用`LongAccumulator`

```
LongAdder adder = new LongAdder();

LongAccumulator accumulator = new LongAccumulator(new LongBinaryOperator(){
  @Override
  public long applyAsLong(long left, long right){
    return left + right;
  }
}, 0);
```

`LongAccumulator`相比于`LongAdder`，可以为累加器提供非0的初始值，后者只能提供默认的0值。另外前者还可以指定累加规则，比如不进行累加而进行相乘，只需要在构造`LongAccumulator`时传入自定义的双目运算器即可，后者则内置累加的规则。

从下面代码我们知道，`LongAccumulator`相比于`LongAdder`的不同之处在于，在调用`casBase`时后者传递的是b+x，前者则使用了`r = function.applyAsLong(b = base, x)`来计算

- `LongAdder`的add

  ```
  public void add(long x) {
          Cell[] as; long b, v; int m; Cell a;
          if ((as = cells) != null || !casBase(b = base, b + x)) {
              boolean uncontended = true;
              if (as == null || (m = as.length - 1) < 0 ||
                  (a = as[getProbe() & m]) == null ||
                  !(uncontended = a.cas(v = a.value, v + x)))
                  longAccumulate(x, null, uncontended);
          }
      }
  ```

- `LongAccumulator`的accumulate

  ```
  public void accumulate(long x) {
          Cell[] as; long b, v, r; int m; Cell a;
          if ((as = cells) != null ||
              (r = function.applyAsLong(b = base, x)) != b && !casBase(b, r)) {
              boolean uncontended = true;
              if (as == null || (m = as.length - 1) < 0 ||
                  (a = as[getProbe() & m]) == null ||
                  !(uncontended =
                    (r = function.applyAsLong(v = a.value, x)) == v ||
                    a.cas(v, r)))
                  longAccumulate(x, function, uncontended);
          }
      }
  ```

另外，前者在调用`longAccumulator`时传递的是function，而后者是null。

从下面代码可知，当fn为null时就使用v+x加法计算，这时候就等价于`LongAdder`，当fn不为null时则使用传递的fn函数计算。

```
else if(casBase(v = base, (fn == null) ? v + x : fn.applyAsLong(v, x)))
```

## `CopyOnWriteArrayList`

### 介绍

并发包的并发List只有`CopyOnWriteArrayList`。

`CopyOnWriteArrayList`是一个线程安全的`ArrayList`，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了写时复制策略。`CopyOnWriteArrayList`的类图结构如图：

![img](E:\软件\Typora\images\1202638-20180609170305682-1886924861.png)

在`CopyOnWriteArrayList`的类图中，每个`CopyOnWriteArrayList`对象里面有一个array数组对象用来存放具体元素，`ReentrantLock`独占锁对象用来保证同时只有一个线程对array进行修改。

### 主要方法源码解析

#### 初始化

首先看下无参构造函数，如下代码在内部创建了一个大小为0的Object数组作为array的初始值。

```
public CopyOnWriteArrayList() {
        setArray(new Object[0]);
}
```

然后看下有参构造函数：

```
// 创建一个List，其内部元素时入参toCopyIn的副本
public CopyOnWriteArrayList(E[] toCopyIn) {
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
        }

// 入参为集合，将集合里面的元素复制到本List
public CopyOnWriteArrayList(Collection<? extends E> c) {
        Object[] elements;
        if (c.getClass() == CopyOnWriteArrayList.class)
            elements = ((CopyOnWriteArrayList<?>)c).getArray();
        else {
            elements = c.toArray();
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elements.getClass() != Object[].class)
                elements = Arrays.copyOf(elements, elements.length, Object[].class);
        }
        setArray(elements);
    }
```

#### 添加元素

`CopyOnWriteArrayList`中用来添加元素的函数有`add(E e),add(inr index, E element),addIfAbsent(E e)和addAllAbsent(Collection<? extends E> c)`等，他们的原理类似，本节以add(E e)为例来讲解：

```
public boolean add(E e) {
        // 获取独占锁
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // 获取array
            Object[] elements = getArray();
            
            // 复制array到新数组，添加元素到新数组
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            
            // 使用新数组替换添加前的数组
            setArray(newElements);
            return true;
        } finally {
            // 释放独占锁
            lock.unlock();
        }
    }
```

在添加元素时，首先复制了一个快照，然后在快照上进行添加，而不是直接在原来数组上进行。

#### 获取指定位置元素

使用`E get(int index)`获取下标为index的元素，如果元素不存在则抛出`IndexOutOfBoundsException`异常

```
public E get(int index) {
        return get(getArray(), index);
    }
    
final Object[] getArray() {
        return array;
    }

private E get(Object[] a, int index) {
        return (E) a[index];
    }
```

在代码中，当线程x调用get方法获取指定位置的元素时，分两步走，首先获取array数组（这里命名为步骤A），然后通过下标访问指定位置的元素（这里命名为步骤B），这是两步操作，但是在整个过程中并没有进行加锁操作。

写时复制策略会产生**弱一致性**问题。

#### 修改指定元素

使用`E set(int index, E element)修改list中指定元素的值，如果指定位置的元素不存在则抛出IndexOutOfBoundsException`异常

```
public E set(int index, E element) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            E oldValue = get(elements, index);

            if (oldValue != element) {
                int len = elements.length;
                Object[] newElements = Arrays.copyOf(elements, len);
                newElements[index] = element;
                setArray(newElements);
            } else {
                // Not quite a no-op; ensures volatile write semantics
                setArray(elements);
            }
            return oldValue;
        } finally {
            lock.unlock();
        }
    }
```

#### 删除元素

删除list里面指定的元素，可以使用`E remove(int index),boolean remove(Object o)和boolean remove(Object o,Object[] snapshot,int index)`等，他们的原理一样

```
public E remove(int index) {
        // 获取独占锁
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // 获取数组
            Object[] elements = getArray();
            int len = elements.length;
            
            // 获取指定元素
            E oldValue = get(elements, index);
            int numMoved = len - index - 1;
            
            // 如果删除的是最后一个元素
            if (numMoved == 0)
                setArray(Arrays.copyOf(elements, len - 1));
            else {
                // 分两次复制删除后剩余的元素到新数组
                Object[] newElements = new Object[len - 1];
                System.arraycopy(elements, 0, newElements, 0, index);
                System.arraycopy(elements, index + 1, newElements, index,
                                 numMoved);
                                 
                // 使用新数组代替老数组                 
                setArray(newElements);
            }
            return oldValue;
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
```

#### 弱一致性的迭代器

遍历列表元素可以使用迭代器。

【如何使用迭代器】，代码如下：

```
public static void main(String[] args){
   CopyOnWriteArrayList<String> arrayList = new CopyOnWriteArrayList<>();
   arrayList.add("hello");
   arrayList.add("alibaba");
        
   Iterator<String> iterator = arrayList.iterator();
   while (iterator.hasNext()){
      System.out.println(iterator.next());
   }
}
```

下面来看`CopyOnWriteArrayList`中迭代器的弱一致性是怎么回事，所谓弱一致性是指返回迭代器后，其他线程对list的增删改对迭代器是不可见的，下面看看这是如何做到的

```
    public Iterator<E> iterator() {
        return new COWIterator<E>(getArray(), 0);
    }
    
    static final class COWIterator<E> implements ListIterator<E> {
        // array的快照版本 
        private final Object[] snapshot;
        
        // 数组下标 
        private int cursor;

        // 构造函数
        private COWIterator(Object[] elements, int initialCursor) {
            cursor = initialCursor;
            snapshot = elements;
        }

        // 是否遍历结束
        public boolean hasNext() {
            return cursor < snapshot.length;
        }

        public boolean hasPrevious() {
            return cursor > 0;
        }

        // 获取元素
        @SuppressWarnings("unchecked")
        public E next() {
            if (! hasNext())
                throw new NoSuchElementException();
            return (E) snapshot[cursor++];
        }

       ...
    }
```

当调用Iterator()方法获取迭代器时实际上会返回一个`COWIterator`对象，`COWIterator`对象的snapshot变量保存了当前list的内容，cursor是遍历list时数据的下标。

其他线程没有对list进行增删改，那么snapshot本身就是list的array，因为它们是引用关系。

但如果在遍历期间其他线程对该list进行了增删改，那么snapshot就是快照了，因为增删改后list里面的数组就被新数组替换了，这时候老数组被snapshot引用。这也说明获取迭代器后，使用该迭代器元素时，其他线程对该list进行的增删改不可见，因为它们操作的是两个不同的数组，这就是弱一致性。

下面通过一个例子来演示多线程下迭代器的弱一致性的效果

```
public class CopyList {
    private static volatile CopyOnWriteArrayList<String> arrayList = new CopyOnWriteArrayList<>();

    public static void main(String[] args) throws InterruptedException {
        arrayList.add("hello");
        arrayList.add("alibaba");
        arrayList.add("welcome");
        arrayList.add("to");
        arrayList.add("hangzhou");

        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                arrayList.set(1,"baba");
                arrayList.remove(2);
                arrayList.remove(3);
            }
        });

        Iterator<String> iterator = arrayList.iterator();

        threadOne.start();

        threadOne.join();

        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

输出结果：

![image-20201213224550010](E:\软件\Typora\images\image-20201213224550010.png)

在如上代码中，main函数首先初始化了`arrayList`，然后在启动线程前获取到了`ArrayList`迭代器。子线程`ThreadOne`启动后首先修改了`ArrayList`的第一个元素的值，然后删除了`ArrayList`中下标为2和3的元素。

主线程在子线程执行完毕后使用获取的迭代器遍历数组元素，从输出结果我们知道在子线程里面进行的操作一个都没有生效，这就是迭代器弱一致性的体现。需要足以的是，获取迭代器的操作必须在子线程操作之前。

> ==这个弱一致性问题影响大吗？==



### 缺点

- 内存占用：如果CopyOnWriteArrayList经常要增删改里面的数据，经常要执行add()、set()、remove()的话，那是比较耗费内存的。因为我们知道每次add()、set()、remove()这些增删改操作都要复制一个数组出来
- 数据一致性：CopyOnWriteArrayList容器只能保证数据的最终一致性，不能保证数据的实时一致性



### 使用场景

整体来说CopyOnWriteArrayList是另类的线程安全的实现，但并不一定是高效的，适合用在读取和遍历多的情境下，不适合写并发高的场景，因为数组的拷贝是非常耗时的，尤其是数据量大的情况下。

### 总结

- CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。

- CopyOnWriteArrayList基于可重入锁机制，增删改操作需要加锁，目的是为了比曼Copy出N个副本出来，导致并发写
- 读操作不需要加锁，这样做的好处是我们可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。
- CopyOnWriteArrayList适合用在读取和遍历多的场景下，并不适合写并发高的场景
- 所以**CopyOnWrite容器是一种读写分离的思想，读和写不同的容器。而Vector在读写的时候使用同一个容器，读写互斥，同时只能做一件事儿。**
- 基于fail-safe机制，不会抛出CurrentModifyException
- 另外CopyOnWriteArrayList提供了弱一致性的迭代器，从而保证在获取迭代器后，其他线程对list的修改是不可见的，迭代器遍历的数组是一个快照

## 锁

### `LockSupport`工具类

作用：挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。

`LockSupport`类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的。

LockSupport是使用Unsafe实现的

主要函数：

#### 1.void park()

如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.park()时会马上返回，否则调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。

如下代码，直接在main函数里面调用park()方法，最终只会输出begin park!，然后当前线程被挂起，这是因为在默认情况下调用线程是不持有许可证的。

```
public static void main(String[] args){
  System.out.println("begin park!");
  LockSupport.park();
  System.out.println("end park!");
}
```

因调用park()方法而被阻塞的线程被其他线程中断而返回时并不会抛出InterruptedException异常

#### 2.void unpark(Thread thread)方法

当一个线程调用unpark()时，如果参数thread线程没有持有thread与LockSupport类关联的许可证，则让thread线程持有。

如果thread之前因调用park()而被挂起，则调用unpark()后，该线程会被唤醒。

如果thread之前没有调用park()，则调用unpark()方法后，再调用park()方法，其会立即返回。

修改代码如下：

```
public static void main(String[] args){
  System.out.println("begin park!");
  // 使当前线程获取到许可证
  LockSupport.unpark(Thread.currentThread());
  // 再次调用park方法
  LockSupport.park();
  System.out.println("end park!");
}
```

该代码输出：

> begin park!
>
> end park!

下面再来看一个例子以加深对park和unpark的理解：

```
public static void main(String[] args) throws InterruptedException {
        Thread  thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("child thread begin park!");
                // 调用park方法，挂起自己
                LockSupport.park();
                System.out.println("child thread unpark");
            }
        });
        
        // 启动子线程
        thread.start();
        
        // 主线程休眠1s
        Thread.sleep(1000);
        
        System.out.println("main thread begin unpark");
        
        // 调用unpark方法让thread线程持有许可证，然后park方法返回
        LockSupport.unpark(thread);
    }
```

输出结果：

![image-20201213230734267](E:\软件\Typora\images\image-20201213230734267.png)

上面代码首先创建了一个子线程thread，子线程启动后调用park方法，由于在默认情况下子线程没有持有许可证，因而他会把自己挂起。

主线程休眠1s是为了让主线程调用unpark方法前让子线程输出child thread begin park！并阻塞

主线程然后执行unpark方法，参数为子线程，这样做的目的是为了让子线程持有许可证，然后子线程调用的park方法就返回了。

park方法返回时不会告诉你因何种原因返回，所以调用者需要根据之前调用park方法的原因，再次检查条件是否满足，如果不满足则还需要调用park方法。

例如，根据调用前后中断状态的对比就可以判断是不是因为被中断才返回的。

为了说明调用park方法后的线程被中断后会返回，我们修改上面的例子代码，删除LockSupport.unpark(thread);然后添加thread.interrupt()l具体代码如下：

```
    public static void main(String[] args) throws InterruptedException {
        Thread  thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("child thread begin park!");
                // 调用park方法，挂起自己，只有被中断才会退出循环
                while (!Thread.currentThread().isInterrupted()){
                    LockSupport.park();
                }
                System.out.println("child thread unpark");
            }
        });

        // 启动子线程
        thread.start();

        // 主线程休眠1s
        Thread.sleep(1000);

        System.out.println("main thread begin unpark");

        // 中断子线程
        thread.interrupt();
    }
```

输出结果为：

![image-20201213231335255](E:\软件\Typora\images\image-20201213231335255.png)

在如上代码中，只有中断子线程才会运行结束，如果子线程不被中断，即使你调用unpark(thread)方法子线程也不会结束。

#### 3.void parkNanos(long nanos)方法

和park方法类似，该方法的不同在于，如果没有拿到许可证，则调用线程会被挂起nanos时间后修改为自动返回。

#### 4.park(Object blocker)方法

```
public static void park(Object blocker) {
        // 获取调用线程
        Thread t = Thread.currentThread();
        // 设置该线程的blocker变量
        setBlocker(t, blocker);
        // 挂起线程
        UNSAFE.park(false, 0L);
        // 线程被激活后清除blocker变量，因为一般都是在线程阻塞时才分析原因
        setBlocker(t, null);
    }
```

Thread类里面有个变量volatile Object parkBlocker，用来存放park方法传递的blocker对象，也就是把blockers变量存放到了调用park方法的线程的成员变量里。

#### 5.void parkNanos(Object blocker,long nanos)方法

相比park(Object blocker)方法多了个超时时间

#### 6.void parkUntil(Object blocker,long deadline)方法

```
public static void parkUntil(Object blocker, long deadline) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        // 表示到deadline时间后返回，单位为毫秒
        UNSAFE.park(true, deadline);
        setBlocker(t, null);
    }
```

### AQS 抽象同步队列

#### 简介

`AbstractQueuedSynchronizer` （简称AQS）类是整个 JUC包的核心类。

JUC中的`ReentrantLock`、`ReentrantReadWriteLock`、`CountDownLatch`、`Semaphore`和`LimitLatch`等同步工具都是基于AQS实现的。



AQS分离出了构建同步器时的通用关注点，这些关注点主要包括如下：

- 资源是可以被同时访问？还是在同一时间只能被一个线程访问？（共享/独占）
- 访问资源的线程如何进行并发管理（等待队列）
- 如果线程等不及资源了，如何从等待队列退出（超时/中断）

这些关注点都是围绕着资源——同步状态（synchronization state）来展开的，AQS将这些通用的关注点封装成了一个个模板方法，让子类可以直接使用。



AQS留给用户的只有两个问题：

- 什么是资源
- 什么情况下资源是可以被访问的

这样一来，定义同步器的难度就大大降低了，用户只要解决好上面两个问题，就能构建出一个性能优秀的同步器。



##### 用户需要自己重写的方法

AQS是通过暴露以下API来让用户解决上面的问题的

| 钩子方法            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `tryAcquire`        | 独占方式。尝试获取资源，成功则返回true，失败则返回false。    |
| `tryRelease`        | 独占方式。尝试释放资源，成功则返回true，失败则返回false。    |
| `tryAcquireShared`  | 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 |
| `tryReleaseShared`  | 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 |
| `isHeldExclusively` | 该线程是否正在独占资源。只有用到condition才需要去实现它。    |

如果你需要实现一个自己的同步器，一般情况下只要继承AQS，并重写AQS中的这几个方法就行了。至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。

需要注意的是：如果你没在子类中重写这几个方法就直接调用了，会直接抛出异常。所以，在你调用这些方法之前必须重写他们。不使用的话可以不重写。



以`ReentrantLock`为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用`tryAcquire()`独占该锁并将state+1,。伺候，其他线程再`tryAcquire()`时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其他线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但是要注意，获取多少次就要释放多少次，这样才能保证state是能回到零态的。

再以`CountDownLatch`为例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程时并行执行的，每个子线程执行完之后`countDown()`一次，state会CAS减1，等到所有子线程都执行完后（即state=0），会`unpark()`主调用线程，然后主调用线程就会从await()函数返回，继续后面的动作。

一般来说，自定义同步器要么是独占方法，要么是共享方法，他们也只需要实现`tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared`中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。



下面是几个常见的同步器对资源的定义：

| 同步器                   | 资源的定义                                                   |
| ------------------------ | ------------------------------------------------------------ |
| `ReentrantLock`          | 资源表示独占锁。State为0表示锁可用；为1表示被占用；为N表示重入的次数 |
| `ReentrantReadWriteLock` | 资源表示共享的读锁和独占的写锁。state逻辑上被分成两个16位的unsigned short，分别记录读锁被多少线程使用和写锁被重入的次数。 |
| `CountDownLatch`         | 资源表示倒数计数器。State为0表示计数器归零，所有线程都可以访问资源；为N表示计数器未归零，所有线程都需要阻塞。 |
| `Semaphore`              | 资源表示信号量或者令牌。State≤0表示没有令牌可用，所有线程都需要阻塞；大于0表示由令牌可用，线程每获取一个令牌，State减1，线程没释放一个令牌，State加1。 |

#### 框架

![img](E:\软件\Typora\images\721070-20170504110246211-10684485.png)

##### 同步状态的管理

它维护了一个`volatile int state`（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。

state的访问方式有三种：

- `getState`()
- `setState`()
- `compareAndSetState`()

```
private volatile int state;
  
protected final int getState() {
    return state;
}

protected final void setState(int newState) {
    state = newState;
}

protected final boolean compareAndSetState(int expect, int update) {
    // See below for intrinsics setup to support this
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```



##### 线程的阻塞和唤醒

在JDK1.5之前，除了内置的监视器机制外，没有其他方法可以安全且便捷的阻塞和唤醒当前线程。

JDK1.5以后，JUC locks包提供了`LockSupport`类来作为线程阻塞和唤醒的工具。



##### 等待队列

等待队列是AQS框架的核心，整个框架的关键其实就是如何在并发状态下管理被阻塞的线程。

等待队列是严格的FIFO队列，是`Craig`，`Landin`和`Hagersten`锁（CLH锁）的一种变种，采用双向循环链表实现，因此也叫CLH队列。



#### 源码详解

##### **结点状态`waitStatus`**

Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。

结点一共有两种类型：独占（**EXCLUSIVE**）和共享（**SHARED**）

每种类型的结点都有一些状态，其中独占结点使用其中的CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)，共享结点使用其中的CANCELLED(1)、SIGNAL(-1)、PROPAGATE(-3)。

| 结点状态  | 值   | 描述                                                         |
| --------- | ---- | ------------------------------------------------------------ |
| CANCELLED | 1    | 取消。表示后驱结点被中断或超时，需要移出队列                 |
| SIGNAL    | -1   | 发信号。表示后驱结点被阻塞了（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。） |
| CONDITION | -2   | Condition专用。表示当前结点在Condition队列中，因为等待某个条件而被阻塞了 |
| PROPAGATE | -3   | 传播。适用于共享模式（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。） |
| INITIAL   | 0    | 默认。新结点会处于这种状态                                   |

注意：负值表示结点处于有效等待状态，而正值表示结点已经被取消。所以源码中很多地方用>0、<0来判断节点的状态是否正常。

> AQS使用CLH队列实现线程的结构管理，而CLH结构正是用前一结点某一属性表示当前结点的状态，之所以这样做是因为在双向链表的结构下，这样更容易实现取消和超时功能。
>
> next指针：用于维护队列顺序，当临界区的资源被释放时，头结点通过next指针找到队首结点。
>
> prev指针：用于在结点（线程）被取消时，让当前结点的前驱直接指向当前结点的后驱完成出队动作。



```
static final class Node {
    
    // 共享模式结点
    static final Node SHARED = new Node();
    
    // 独占模式结点
    static final Node EXCLUSIVE = null;

    static final int CANCELLED =  1;

    static final int SIGNAL    = -1;

    static final int CONDITION = -2;

    static final int PROPAGATE = -3;

    /**
    * INITAL：      0 - 默认，新结点会处于这种状态。
    * CANCELLED：   1 - 取消，表示后续结点被中断或超时，需要移出队列；
    * SIGNAL：      -1- 发信号，表示后续结点被阻塞了；（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）
    * CONDITION：   -2- Condition专用，表示当前结点在Condition队列中，因为等待某个条件而被阻塞了；
    * PROPAGATE：   -3- 传播，适用于共享模式。（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）
    * 
    * waitStatus表示的是后续结点状态，这是因为AQS中使用CLH队列实现线程的结构管理，而CLH结构正是用前一结点某一属性表示当前结点的状态，这样更容易实现取消和超时功能。
    */
    volatile int waitStatus;

    // 前驱指针
    volatile Node prev;

    // 后驱指针
    volatile Node next;

    // 结点所包装的线程
    volatile Thread thread;

    // Condition队列使用，存储condition队列中的后继节点
    Node nextWaiter;

    Node() {
    }

    Node(Thread thread, Node mode) { 
        this.nextWaiter = mode;
        this.thread = thread;
    }
}
```



##### `acquire(int)`

**该方法以独占方式获取资源，如果获取到该资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。**

这也正是lock()的语义，当然不仅仅只限于lock()。

获取到资源后，线程就可以去执行其临界区代码了。

下面是acquire()的源码：

```
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

函数流程如下：

1. `tryAcquire()`尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接去抢占加塞一次，而CLH队列中可能还有别的线程在等待）
2. `addWaiter()`将该线程加入等待队列的尾部，并标记为独占模式
3. `acquireQueued()`使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false
4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断`selfInterrupt()`，将中断补上



###### `tryAcquire(int)`

此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。

这也正是`tryLock()`的语义，还是那句话，当然不仅仅只限于`tryLock()`。

如下是`tryAcquire()`的源码：

```
protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
```

什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取释放方式交由自定义同步器去实现吗？就是这里了。

AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get、set、CAS）。至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了。当然，自定义同步器在进行资源访问时要考虑线程安全的影响。

这里之所以没有定义成abstract，是因为独占模式下只用实现`tryAcquire-tryRelease`，而共享模式下只用实现`tryAcquireShared-tryReleaseShared`。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。



###### `addWaiter(Node)`

**此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点**

```
private Node addWaiter(Node mode) {
        // 以给定模式构造结点。mode有两种，EXCLUSIVE和SHAVED
        Node node = new Node(Thread.currentThread(), mode);
        
        // 尝试快速方式直接放到队尾
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        
        // 上一步失败则通过enq入队
        enq(node);
        return node;
    }
```



###### **`enq(Node)`**

**此方法用于将node加入队尾**

```
private Node enq(final Node node) {
        // CAS自旋，直到成功加入队尾
        for (;;) {
            Node t = tail; (1)
            
            // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它
            if (t == null) { 
                if (compareAndSetHead(new Node()))  (2)
                    tail = head;
            } else {
                // 正常流程放入队尾
                node.prev = t;  (3)
                if (compareAndSetTail(t, node)) { (4)
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

如果你看过`AtomicInteger.getAndIncrement()`函数源码，那么相信你一眼便看出这段代码的精华。**CAS自旋volatile变量**，是一种很经典的用法。

如上代码在第一次循环中，当要在AQS队列尾部插入元素时，AQS队列状态如下图中default所示。也就是队列头、尾节点都指向null，当执行代码(1)后节点指向了尾部节点，这时候队列状态如图中(I)所示。

这时候t为null，故执行代码（2），使用CAS算法设置一个哨兵节点为头节点，如果CAS设置成功，则让尾部节点也指向哨兵节点，这时候队列状态如图中（II）所示。

到现在为止只插入了一个哨兵节点，还需要插入node节点，所以在第二次循环后执行到代码（1），这时候队列状态如图中（III）所示；然后执行代码（3）设置node的前驱节点为尾部节点，这时候队列状态如图中（IV）所示；

然后通过CAS算法设置node节点为尾部节点，CAS成功后队列状态如图中（V）所示；

CAS成功后再设置原来的尾部节点的后驱节点为node，这时候就完成了双向链表的插入，此时队列状态如图中（VI）所示。

![img](https://img2018.cnblogs.com/blog/1775037/202002/1775037-20200228143916512-2114683301.jpg)



###### `acquireQueued(Node, int)`

OK，通过`tryAcquire()`和`addWaiter()`，该线程获取资源失败，已经被放入等待队列尾部了，聪明的你立即应该能想到该线程下一步该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~`acquireQueued()`就是干这件事：**在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回**。这个函数非常关键，还是上源码吧：

```
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true; // 标记是否成功拿到资源
        try {
            boolean interrupted = false; // 标记等待过程中是否被中断过
            
            // 又是一个自旋
            for (;;) {
                final Node p = node.predecessor(); // 拿到前驱
                
                // 如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自                    己的，当然也可能被interrupt了）
                if (p == head && tryAcquire(arg)) {
                
                    setHead(node); //拿到资源后，将head指向该结点。所以head所指的标杆结点,就是当前获取到资                                      源的那个结点或null
                    
                    p.next = null; //setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便                                      GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！
                    
                    failed = false; // 成功获取资源
                    return interrupted; //返回等待过程中是否被中断过
                }
                
                //如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中                   断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    
                    interrupted = true; //如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为                                           true
            }
        } finally {
            if (failed) // 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取                            消结点在队列中的等待。
                cancelAcquire(node);
        }
    }
```

到这里了，我们先不着急总结`acquireQueued()`的函数流程，先看看`shouldParkAfterFailedAcquire()`和`parkAndCheckInterrupt()`具体干些什么



**`shouldParkAfterFailedAcquire(Node, Node)`**

此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态），万一队列前边的线程都放弃了只是瞎站着，那也说不定。

```
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus; // 拿到前驱状态
        if (ws == Node.SIGNAL)
        
            // 如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了
            return true;
            
        if (ws > 0) {
            /*
             * 如果前驱放弃了，那就一直往前找，知道找到最近一个正常等待的状态，并排在他的后边
             * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安              * 大叔赶走了(GC回收)！
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node; 
        } else {
            // 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下，有可能失败，人家说不                定刚刚释放呢
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
```

整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。



**`parkAndCheckInterrupt()`**

如果线程找好安全休息点后，那就可以安心去休息了，此方法就是让线程去休息，真正进入等待状态

```
private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
```

park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：

1）被`unpark()`

2）被interrupt()



**小结**

OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：

1. 结点进入队尾后，检查状态，找到安全休息点；
2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；
3. 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。



###### 小结

`acquireQueued()`分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：

```
 public final void acquire(int arg) {
     if (!tryAcquire(arg) &&
         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
         selfInterrupt();
 }
```

再来总结下它的流程吧：

1. 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；
2. 没成功，则`addWaiter()`将该线程加入等待队列的尾部，并标记为独占模式；
3. acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。
4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。

由于此函数是重中之重，我再用流程图总结一下：

![img](E:\软件\Typora\images\721070-20151102145743461-623794326.png)

至此，acquire()的流程终于算是告一段落了。这也就是`ReentrantLock.lock()`的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！



##### `release(int)`

上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。

此方法是独占模式下线程释放共享资源的顶层入口。

它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。

这也正是unlock()的语义，当然不仅仅只限于unlock()。

下面是release()的源码：

```
public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head; // 找到头结点
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h); // 唤醒等待队列里的下一个线程
            return true;
        }
        return false;
    }
```

逻辑并不复杂。它调用`tryRelease()`来释放资源。

有一点需要注意的是，**它是根据`tryRelease()`的返回值来判断该线程是否已经完成释放掉资源了！**

**所以自定义同步器在设计`tryRelease()`的时候要明确这一点！！**



###### `tryRelease(int)`

此方法尝试去释放指定量的资源

```
protected boolean tryRelease(int arg) {
        throw new UnsupportedOperationException();
    }
```

跟`tryAcquire()`一样，这个方法是需要独占模式的自定义同步器去实现的。

正常来说，`tryRelease()`都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(`state-=arg`)，也不需要考虑线程安全的问题。

但要注意它的返回值，上面已经提到了，**release()是根据`tryRelease()`的返回值来判断该线程是否已经完成释放掉资源了！**

所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。



###### `unparkSuccessor(Node)`

此方法用于唤醒等待队列中下一个线程。下面是源码：

```
    private void unparkSuccessor(Node node) {
        // 这里，node一般为当前线程所在的结点
        int ws = node.waitStatus;
        if (ws < 0) // 置零当前线程所在的结点状态，允许失败
            compareAndSetWaitStatus(node, ws, 0);

        // 找到下一个需要唤醒的结点
        Node s = node.next;
        if (s == null || s.waitStatus > 0) { // 如果为空或者已取消
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev) //从后往前找
                if (t.waitStatus <= 0) //从这里可以看出<=0的结点都是还有效的结点
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);//唤醒
    }
```

这个函数并不复杂。一句话概括：**用`unpark()`唤醒等待队列中最前边的那个未放弃线程**，这里我们也用s来表示吧。

此时，再和`acquireQueued()`联系起来，s被唤醒后，进入`if (p == head && tryAcquire(arg))`的判断（即使p!=head也没关系，它会再进入`shouldParkAfterFailedAcquire()`寻找一个安全点。

这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过`shouldParkAfterFailedAcquire()`的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!

###### 小结

release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。

**如果获取锁的线程在release时异常了，没有`unpark`队列中的其他结点，这时队列中的其他结点会怎么办？是不是没法再被唤醒了？**

答案是**YES**！！！这时，队列中等待锁的线程将永远处于park状态，无法再被唤醒！！！

但是我们再回头想想，获取锁的线程在什么情形下会release抛出异常呢？？

1. 线程突然死掉了？可以通过`thread.stop`来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；

2. 线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；

3. release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。

   **除非自己写的`tryRelease()`有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了**。



##### `acquireShared(int)`

此方法是共享模式下线程获取共享资源的顶层入口。

它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。

下面是`acquireShared()`的源码：

```
public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }
```

这里`tryAcquireShared()`依然需要自定义同步器去实现。

但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。

所以这里`acquireShared()`的流程就是：

1. tryAcquireShared()尝试获取资源，成功则直接返回；
2. 失败则通过`doAcquireShared()`进入等待队列，直到获取到资源为止才返回。



###### `doAcquireShared(int)`

此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。

下面是`doAcquireShared()`的源码：

```
private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);//加入尾部队列
        boolean failed = true;//是否成功标志
        try {
            boolean interrupted = false;//等待过程中是否被中断过的标志
            for (;;) {
                final Node p = node.predecessor();//前驱
                if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是                                     head用完资源来唤醒自己的
                    int r = tryAcquireShared(arg);//尝试获取资源
                    if (r >= 0) {//成功
                        setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程
                        p.next = null; // help GC
                        if (interrupted)//如果等待过程中被打断过，此时将中断补上
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。

跟独占模式比，还有一点需要注意的是，这里只有线程是`head.next`时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。

那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。



######  `setHeadAndPropagate(Node, int)`

```
    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; 
        setHead(node);//head指向自己
        //如果还有剩余量，继续唤醒下一个邻居线程
        if (propagate > 0 || h == null || h.waitStatus < 0 ||
            (h = head) == null || h.waitStatus < 0) {
            Node s = node.next;
            if (s == null || s.isShared())
                doReleaseShared();
        }
    }
```

此方法在`setHead()`的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！

###### 小结

OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：

1. 1. tryAcquireShared()尝试获取资源，成功则直接返回；
   2. 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。

　　其实跟acquire()的流程大同小异，只不过多了个**自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）**。



##### `releaseShared()`

上一小节已经把`acquireShared()`说完了，这一小节就来讲讲它的反操作`releaseShared()`吧。

此方法是共享模式下线程释放共享资源的顶层入口。

它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。

下面是`releaseShared()`的源码：

```
public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {//尝试释放资源
            doReleaseShared();//唤醒后继结点
            return true;
        }
        return false;
    }
```

此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。

跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的`tryRelease()`在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的`releaseShared()`则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。

例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后`tryReleaseShared(2)`返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，`tryReleaseShared(2)`返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而`ReentrantReadWriteLock`读锁的`tryReleaseShared()`只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定`tryReleaseShared()`的返回值。



###### `doReleaseShared()`

此方法主要用于唤醒后继

```
private void doReleaseShared() {
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            
                    unparkSuccessor(h);//唤醒后继
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head) //head发生变化
                break;
        }
    }
```

##### 小结

本节我们详解了独占和共享两种模式下获取-释放资源(`acquire-release、acquireShared-releaseShared`)的源码，相信大家都有一定认识了。值得注意的是，acquire()和`acquireShared()`两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，`acquireInterruptibly()/acquireSharedInterruptibly()`即是，相应的源码跟acquire()和`acquireShared()`差不多，这里就不再详解了。



#### 简单应用

##### Mutex（互斥锁）

Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。

下边是Mutex的核心源码：

```
class Mutex implements Lock, java.io.Serializable {
    // 自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 判断是否锁定状态
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 尝试获取资源，立即返回。成功则返回true，否则false。
        public boolean tryAcquire(int acquires) {
            assert acquires == 1; // 这里限定只能为1个量
            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！
                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源
                return true;
            }
            return false;
        }

        // 尝试释放资源，立即返回。成功则为true，否则false。
        protected boolean tryRelease(int releases) {
            assert releases == 1; // 限定为1个量
            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);//释放资源，放弃占有状态
            return true;
        }
    }

    // 真正同步类的实现都依赖继承于AQS的自定义同步器！
    private final Sync sync = new Sync();

    //lock<-->acquire。两者语义一样：获取资源，即便等待，直到成功才返回。
    public void lock() {
        sync.acquire(1);
    }

    //tryLock<-->tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    //unlock<-->release。两者语文一样：释放资源。
    public void unlock() {
        sync.release(1);
    }

    //锁是否占有状态
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
}

```

同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式`tryAcquire-tryRelelase`，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。

　　除了`Mutex，ReentrantLock/CountDownLatch/Semphore`这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式`tryAcquire-tryRelelase`。掌握了这点，AQS的核心便被攻破了！



> 参考：
>
> [并发编程之美]()
>
> [并发编程的基石——AQS类](https://www.cnblogs.com/54chensongxia/p/11970870.html)



### Condition

#### 接口简介

Condition可以看做是Object类的`wait()`、`notify()`、`notifyAll()`方法的替代品，与Lock配合使用。
当线程执行condition对象的`await`方法时，当前线程会立即释放锁，并进入对象的等待区，等待其它线程唤醒或中断。



#### 接口定义

```
public interface Condition {

    void await() throws InterruptedException;

    long awaitNanos(long nanosTimeout) throws InterruptedException;
    
    boolean await(long time, TimeUnit unit) throws InterruptedException;

    boolean awaitUntil(Date deadline) throws InterruptedException;

    void signal();

    void signalAll();
}
```



#### 使用示例

wait-notify模式的一个典型应用就是可以实现生产者-消费者模式。让我印象很深是我毕业那年阿里巴巴校园招聘的一个笔试题：

> 有一个苹果箱，有10个人向这个箱子中每次随机放入一个苹果，有10个人每次随机从这个箱子中随机拿走一个苹果，同时需要满足箱子中的苹果总数不能超过50个。请用代码实现上面的场景（不能使用并发集合框架）

这个题目使用wait-notify模式可以很好地解决。下面使用`Condition`模式来写下。

```
public class AppleBoxConditon {

    private int appleCount;
    private static Lock lock = new ReentrantLock();
    private static Condition fullCondition = lock.newCondition();
    private static Condition emptyCondition = lock.newCondition();

    public void putApple() {
        lock.lock();
        try {
            while (appleCount >= 10) {
                try {
                    fullCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            appleCount++;
            System.out.println("放入一个,当前盒子中苹果数:" + appleCount);
            emptyCondition.signalAll();
        } finally {
            lock.unlock();
        }
    }


    public void takeApple() {
        lock.lock();
        try{
            while (appleCount <= 0) {
                try {
                    emptyCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            appleCount--;
            System.out.println("拿走一个,当前盒子中苹果数:" + appleCount);
            fullCondition.signalAll();
        }finally {
            lock.unlock();
        }
    }

    private static class AppleTaker implements Runnable {

        private AppleBoxConditon appleBox;

        public AppleTaker(AppleBoxConditon appleBox) {
            this.appleBox = appleBox;
        }

        @Override
        public void run() {
            while (true) {
                appleBox.takeApple();
                try {
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }


    private static class ApplePutter implements Runnable {

        private AppleBoxConditon appleBox;

        public ApplePutter(AppleBoxConditon appleBox) {
            this.appleBox = appleBox;
        }

        @Override
        public void run() {
            while (true) {
                appleBox.putApple();
                try {
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }


    public static void main(String[] args) {
        AppleBoxConditon appleBox = new AppleBoxConditon();


        for (int i = 0; i < 20; i++) {
            Thread t = new Thread(new AppleBoxConditon.ApplePutter(appleBox));
            t.setName("ApplePutter:"+i);
            t.start();
        }

        for (int i = 0; i < 20; i++) {
            Thread t = new Thread(new AppleBoxConditon.AppleTaker(appleBox));
            t.setName("AppleTaker:"+i);
            t.start();
        }

    }

}
```



### `ReentrantLock`

查看ReentrantLock的源代码，我们会看到两个构造函数，分为对应构造公平锁和非公平锁

```
//默认构造非公平锁
public ReentrantLock() {
    sync = new NonfairSync();
}
//true构造公平锁，false构造非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

**公平锁**：是指线程在抢占锁失败后会进入一个等待队列，先进入队列的线程会先获得锁。公平性体现在先来先得。
**非公平锁**：是指线程抢占锁失败后会进入一个等待队列，但是这些等待线程谁能先获得锁不是按照先来先得的规则，而是随机的。不公平性体现在后来的线程可能先得到锁。

如果有很多线程竞争一把公平锁，系统的总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时在线程调度上面的开销比较大。

原因是采用公平策略时，当一个线程释放锁时，需要先将等待队列中的线程唤醒。这个唤醒的调度过程是比较耗费时间的。如果使用非公平锁的话，当一个线程释放锁之后，可用的线程能立马获得锁，效率较高。

**ReentrantLock代码实现**

1. 非公平锁代码

   ```
   static final class NonfairSync extends Sync {
   
       private static final long serialVersionUID = 7316153563782823691L;
   
       /**
        * Performs lock.  Try immediate barge, backing up to normal
        * acquire on failure.
        */
       final void lock() {
           //如果没有线程占据锁，则占据锁，也就是将state从0设置为1
           //这种抢占方式不要排队，有人释放了锁，你可以直接插到第一位
           //去抢，只要你能抢到
           if (compareAndSetState(0, 1))
               setExclusiveOwnerThread(Thread.currentThread());
           else
           //否则尝试抢占锁
               acquire(1);
       }
   
       protected final boolean tryAcquire(int acquires) {
           return nonfairTryAcquire(acquires);
       }
   }
   ```

   通过之前对AQS的介绍，我们知道抢占锁的时候会调用 tryAcquire 方法。非公平锁的这个方法直接调用了父类中的`nonfairTryAcquire`。

   ```
   
   final boolean nonfairTryAcquire(int acquires) {
       final Thread current = Thread.currentThread();
       int c = getState();
       //锁已经被释放，则直接占据锁
       if (c == 0) {
           if (compareAndSetState(0, acquires)) {
               setExclusiveOwnerThread(current);
               return true;
           }
       }
       //否则判断锁是不是之前被自己占用过，并设置重入次数
       else if (current == getExclusiveOwnerThread()) {
           int nextc = c + acquires;
           if (nextc < 0) // overflow
               throw new Error("Maximum lock count exceeded");
           setState(nextc);
           return true;
       }
       return false;
   }
   
   ```

2. 公平锁代码

   ```
   
   static final class FairSync extends Sync {
           private static final long serialVersionUID = -3000897897090466540L;
   
           final void lock() {
               acquire(1);
           }
           
           protected final boolean tryAcquire(int acquires) {
               final Thread current = Thread.currentThread();
               int c = getState();
               if (c == 0) {
                   //没人在队列中排队，并且锁已经被释放才能抢占到锁，否则去队列中排队
                   if (!hasQueuedPredecessors() &&
                       compareAndSetState(0, acquires)) {
                       setExclusiveOwnerThread(current);
                       return true;
                   }
               }
               //设置重入次数
               else if (current == getExclusiveOwnerThread()) {
                   int nextc = c + acquires;
                   if (nextc < 0)
                       throw new Error("Maximum lock count exceeded");
                   setState(nextc);
                   return true;
               }
               return false;
           }
       }
   
   ```

### `ReentrantReadWriteLock`

#### `ReadWriteLock`接口简介

ReadWriteLock接口是一个单独的接口（未继承Lock接口），该接口提供了获取读锁和写锁的方法。

> 所谓读写锁，是一对相关的锁——读锁和写锁，读锁用于只读操作，写锁用于写入操作。读锁可以由多个线程同时保持，而写锁是独占的，只能由一个线程获取。

接口内容：

```
public interface ReadWriteLock {
    /**
     * Returns the lock used for reading.
     *
     * @return the lock used for reading
     */
    Lock readLock();

    /**
     * Returns the lock used for writing.
     *
     * @return the lock used for writing
     */
    Lock writeLock();
}
```

由于读写锁本身的实现就远比独占锁复杂，因此，读写锁比较适用于以下情形：

1. 高频次的读操作，相对较低频次的写操作
2. 读操作所用时间不会太短（否则读写锁本身的复杂实现所带来的开销会成为主要消耗成本）



#### ReetrantReadWriteLock简介

ReentrantReadWriteLock类，它是ReadWriteLock接口的直接实现，该类在内部实现了具体独占锁特点的写锁，以及具有共享锁特点的读锁，和ReentrantLock一样，ReentrantReadWriteLock类也是通过定义内部类实现AQS框架的API来实现独占/共享功能。

ReentrantReadWriteLock具有如下特点：

- 支持公平/非公平策略

  和ReadWriteLock类一样，ReentrantReadWriteLock对象在构造时，可以传入参数指定是公平锁还是非公平锁

  ```
  public ReentrantReadWriteLock() {
      this(false);
  }
  
  public ReentrantReadWriteLock(boolean fair) {
      sync = fair ? new FairSync() : new NonfairSync();
      readerLock = new ReadLock(this);
      writerLock = new WriteLock(this);
  }
  ```

- 支持锁重入

  - 同一读线程在获取了读锁后还可以获取读锁
  - 同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁

- 支持锁降级

  所谓锁降级，就是先获取写锁，然后获取读锁，最后释放写锁，这样写锁就降级成了读锁。

  但是读锁不能升级到写锁。

- Condition条件支持

  ReentrantReadWriteLock的内部读锁类、写锁类实现了Lock接口，所以可以通过newCondition()方法获取Condition对象。

  但是这里要注意，读锁是没法获取Condition对象的，读锁调用newCondition()方法会直接抛出UnsupportedOperationException

  > 我们知道，condition的作用其实是对Object类的wait()和notify()的增强，是为了让线程在指定对象上等待，是一种线程之间进行协调的工具。
  >
  > 当线程调用condition对象的await()方法时，必须拿到和这个condition对象关联的锁。由于线程对读锁的访问时不受限制的（在写锁未被占用的情况下），那么即使拿到了和读锁关联的condition对象也是没有意义的，因为读线程之前不需要进行协调。

- 使用示例

  以下是Oracle官方给出的一个例子：
  使用ReentrantReadWriteLock控制对TreeMap的访问（利用读锁控制读操作的访问，利用写锁控制修改操作的访问），将TreeMap包装成一个线程安全的集合，并且利用了读写锁的特性来提高并发访问。

  ```
  public class RWTreeMap {
      private final Map<String, Data> m = new TreeMap<String, Data>();
      private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
      private final Lock r = rwl.readLock();
      private final Lock w = rwl.writeLock();
   
      public Data get(String key) {
          r.lock();
          try {
              return m.get(key);
          } finally {
              r.unlock();
          }
      }
   
      public String[] allKeys() {
          r.lock();
          try {
              return (String[]) m.keySet().toArray();
          } finally {
              r.unlock();
          }
      }
   
      public Data put(String key, Data value) {
          w.lock();
          try {
              return m.put(key, value);
          } finally {
              w.unlock();
          }
      }
   
      public void clear() {
          w.lock();
          try {
              m.clear();
          } finally {
              w.unlock();
          }
      }
  }
  ```


## 并发队列

## 线程池

### 线程池的优势

1. 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗
2. 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行
3. 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的，需要保持当前执行线程的现场，并恢复要执行线程的现场）
4. 通过更强大的功能，延时定时线程池



### 线程池的主要参数

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

1. corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程池数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize(除了会利用提交新任务来创建和启动线程，也可以通过prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程)
2. maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数，当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务，另外，对于无界队列，可忽略该参数
3. keepAliveTime（线程存活保持时间）：当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数
4. `unit=> `keepAliveTime的时间单位,比如分钟,小时等
5. workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列
6. threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）
7. handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略



### 线程池流程

![img](https://upload-images.jianshu.io/upload_images/6024478-88ee7b20f8f45825.png?imageMogr2/auto-orient/strip|imageView2/2/w/937/format/webp)

1. 判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务
2. 判断任务队列是否已满，没满则将新提交的任务添加在工作任务
3. 判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和策略



### Java中提供的线程池

1. newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载比较轻的场景，执行短期异步任务（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）
2. newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制（保证线程数可控，不会造成线程过多，导致系统负载更为严重）
3. newSingleThreadPool：创建一个单线程的线程池，适用于需要保证顺序执行各个任务
4. newScheduledThreadPool：适用于执行延时或者周期性任务





# 面试题

## 基础

### 1.进程和线程？

线程是进程划分成更小的运行单位，线程和进程最大的不同在于基本上各进程是福独立的，而各线程则不一定，因为同一进程中的线程可能会相互影响。线程执行开销小，但不利于资源的管理和保护，而进程相反。



### 2.线程的生命周期和状态？

新建 就绪 运行 阻塞 死亡



### 3.线程死锁？如何避免死锁？

1. 资源互斥
2. 请求与保持
3. 不剥夺
4. 循环等待



预防死锁：

1. 破坏请求与保持条件：一次性申请所有资源
2. 破坏不剥夺条件：如果申请不到，主动释放当前占有资源
3. 破坏循环等待条件：按顺序

 

避免死锁：

借助算法（如银行家算法）进行评估，使其进入安全状态



### 4.sleep()和wait()方法区别和共同点？

sleep()休眠不释放锁，自动苏醒，继承自Thread类

wait()会主动释放锁，等待唤醒，继承自Object类



### 5.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

调用start()方法线程进入就绪状态，等待分配时间片进入运行状态

直接调用run()方法会把run()当做一个普通方法执行



### 6.synchronized关键字

重量级锁，JVM层面

修饰同步代码块时：通过JVM指令操作控制，加锁时monitor enter，里面有一个计数器，所以是可重入的，释放锁时monitor exit

修饰方法时：ACC_SYNCHRONIZED标识

在Java1.6之后，进行了锁优化，比如锁自旋，锁粗化，锁膨胀（无锁 - 偏向锁 -轻量级锁 -重量级锁）等



### 7.synchronized和ReentrantLock的区别

1. synchronized是操作系统层面的，ReentrantLock是API层面
2. ReentrantLock需要显式地加锁释放锁
3. ReentrantLock可以实现公平和非公平锁，等待可中断，可实现选择性通知
4. 两者都是可重入锁



### 8.volatile关键字

1. 防止指令重排序（内存屏障）
2. 保证可见性



### 9.ThreadLocal

1. ThreadLocalMaps
2. 内存泄漏，ThreadLocalMap中key为ThreadLocal变量是弱引用，value是强引用



### 10.实现Runnable和Callable接口的区别？

- Runnable接口不会返回结果或者抛出检查异常，Callable接口可以



### 11.执行execute()和submit()方法的区别？

- execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
- submit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象



### 12.如何创建线程池？

ThreadPoolExecutor

- 通过构造方法实现
- 通过Executors的工具类Executors实现



### 13.线程池核心参数：

核心线程数

最大线程数

时间单位

存活时间

拒绝策略

工作队列



### 14.Atomic原子类

CAS+volatile+native方法



### 15.AQS

构建锁和同步器的框架

如ReentrantLock、Semaphore等



核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态，如果被请求的资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS使用CLH实现的，即将暂时获取不到锁的线程加入到队列中。



Semaphore：允许多个线程同时访问

CountDownLatch：倒计时器，可以让某一个线程等待倒计时结束再开始执行

CyclicBarrier：循环栅栏，可以实现线程间的等待，让一组线程到达一个屏障



### 16.用过CountDownLatch吗？什么场景下用的？

多线程读取多个文件，需要将这几个文件处理的结果进行统计整理

