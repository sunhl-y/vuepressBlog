## synchronized

### 对象

#### 对象头（header）

MarkWord 标记字段（存储对象的hashcode,分代年龄和锁标志位信息）

Klass Point 类型指针（对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例）

Monitor(EntryList，Owner（会指向持有monitor对象的线程），waitSet)

#### 实例数据

#### 对齐填充

### 方法

ACC_SYNCHRONIZED

### 代码块

monitorenter

monitorexit

程序计数器 count



### 锁升级

无锁 - 偏向锁 - 轻量级锁 - 重量级锁，不可降级

（下图无锁和偏向锁 锁标志位都是01）

![在这里插入图片描述](../../images/20200603161323889.png)





### 特性保证

#### 有序性

as-if-serial

happens-before

#### 可见性

内存强制刷新

#### 原子性

单一线程持有

#### 可重入性

计数器

### 重锁

用户态内核态切换

### sync 和 Lock的区别

synchronized是关键字，是JVM层面的底层啥都帮我们做了，而Lock是一个接口，是JDK层面的有丰富的API。
synchronized会自动释放锁，而Lock必须手动释放锁。
synchronized是不可中断的，Lock可以中断也可以不中断。
通过Lock可以知道线程有没有拿到锁，而synchronized不能。
synchronized能锁住方法和代码块，而Lock只能锁住代码块。
Lock可以使用读锁提高多线程读效率。
synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。

#### 劣势

锁升级不可逆

## ThreadLocal

#### 内存泄露

#### session

## Lock

### ReentrantReadWriteLock

### ReentrantLock

### StampedLock

## volatile

## 线程池

### newFixedThreadPool

### newCacheThreadPool

### newSIngleTheadExecutor

### newScheduledThewadPool

### newWorkStealingPool

### ThreadPoolExecutor

### 参数意义

#### 核心线程数

#### 最大线程数

#### 空闲时间&单位

#### 缓冲队列

#### 工厂方法

#### 拒绝策略

#### 使用has表维护线程的引用

#### submit

### 实际使用

#### 商品详情页面

#### 批处理

### 执行过程

核心线程->队列->最大线程->拒绝策略

### 运行状态

### 故障

### JUC

### 常见问题

#### 线程间是怎么通信的

可以介绍一下wait/notify，共享变量的synchronized或者lock的同步机制等

volatile

countdownlatch

cyclicbarrier

#### ThreadLocal 用来解决什么问题？

可以从尽量减少临界区范围，使用 ThreadLocal，减少线程切换、使用读写锁或 copyonwrite 等机制这些方面来回答。

#### 如何尽可能提高多线程并发性能？

ThreadLocal 是如何实现的？可以重点回答 ThreadLocal 不是用来解决多线程共享变量的问题，而是用来解决线程数据隔离

#### 读写锁适用于什么场景？

可以回答读写锁适合读并发多，写并发少的场景，另外一个解决这种场景的方法是 copyonwrite。

#### 如何实现一个生产者与消费者模型？

可以尝试通过锁、信号量、线程通信、阻塞队列等不同方式实现。

### 线程状态

### countDownLatch

只有一个构造方法 只会被赋值一次

没有别的方法可以修改 count



# 面试题

## 1.锁升级过程，对象头结构？

锁升级过程

无锁 - 偏向锁（线程访问同步块） - 轻量级锁（有别的线程竞争） - 重量级锁 （自旋十次获取锁失败）

对象头：markword（存放锁标志位，分代年龄等），klass pointer（类型指针），monitor